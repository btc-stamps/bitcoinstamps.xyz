<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="The Original Trinity (Mikeinspace, Arwyn, Reinamora)" />
  <meta name="author" content="Bitcoin Stamps Community" />
  <meta name="dcterms.date" content="2026-02-16" />
  <title>Bitcoin Stamps Protocol: A Technical Whitepaper</title>
  <style>
    html {
      font-family: Liberation Serif;
      font-size: 10pt;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 1in;
      padding-right: 1in;
      padding-top: 1in;
      padding-bottom: 1in;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    div.abstract {
      margin: 2em 2em 2em 2em;
      text-align: left;
      font-size: 85%;
    }
    div.abstract-title {
      font-weight: bold;
      text-align: center;
      padding: 0;
      margin-bottom: 0.5em;
    }
    code {
      font-family: Liberation Mono;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
<style>
body { max-width: 900px; margin: 2rem auto; padding: 0 1.5rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; line-height: 1.7; color: #1a1a1a; }
h1 { font-size: 2rem; border-bottom: 2px solid #e2e2e2; padding-bottom: 0.5rem; }
h2 { font-size: 1.5rem; margin-top: 2.5rem; border-bottom: 1px solid #eee; padding-bottom: 0.3rem; }
h3 { font-size: 1.2rem; margin-top: 2rem; }
code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; font-size: 0.9em; }
pre { background: #f4f4f4; padding: 1rem; border-radius: 6px; overflow-x: auto; }
pre code { background: none; padding: 0; }
table { border-collapse: collapse; width: 100%; margin: 1rem 0; }
th, td { border: 1px solid #ddd; padding: 8px 12px; text-align: left; }
th { background: #f8f8f8; font-weight: 600; }
tr:nth-child(even) { background: #fafafa; }
blockquote { border-left: 4px solid #ddd; margin: 1rem 0; padding: 0.5rem 1rem; color: #555; }
a { color: #2563eb; text-decoration: none; }
a:hover { text-decoration: underline; }
nav#TOC { background: #f8f9fa; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem; }
nav#TOC > ul { margin: 0; }
@media print { body { max-width: none; } nav#TOC { break-after: page; } h1, h2 { break-after: avoid; } }
</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Bitcoin Stamps Protocol: A Technical Whitepaper</h1>
<p class="subtitle">A Technical Whitepaper — Version 1.0</p>
<p class="author">The Original Trinity (Mikeinspace, Arwyn,
Reinamora)</p>
<p class="author">Bitcoin Stamps Community</p>
<p class="date">2026-02-16</p>
<div class="abstract">
<div class="abstract-title">Abstract</div>
<p>Bitcoin Stamps is a metaprotocol for creating permanent, immutable
digital assets on Bitcoin through direct UTXO storage. Unlike
witness-data approaches, Bitcoin Stamps embed asset data in transaction
outputs using bare multisig and P2WSH encoding, ensuring universal node
storage and consensus-critical permanence.</p>
<p>The protocol evolved from Counterparty foundations (block 779,652,
March 29, 2023) through native Bitcoin encoding (block 793,068) to P2WSH
optimization via OLGA (block 865,000, October 15, 2023). Built on
account-based asset tracking, Bitcoin Stamps support fungible tokens
(SRC-20), non-fungible assets (base stamps), decentralized naming
(SRC-101), and composable recursion (SRC-721).</p>
</div>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#version-history" id="toc-version-history"><span
class="toc-section-number">1</span> Version History</a></li>
<li><a href="#introduction" id="toc-introduction"><span
class="toc-section-number">2</span> 1. Introduction</a>
<ul>
<li><a href="#motivation" id="toc-motivation"><span
class="toc-section-number">2.1</span> 1.1 Motivation</a></li>
<li><a href="#historical-context" id="toc-historical-context"><span
class="toc-section-number">2.2</span> 1.2 Historical Context</a>
<ul>
<li><a href="#counterparty-foundation-2014-2023"
id="toc-counterparty-foundation-2014-2023"><span
class="toc-section-number">2.2.1</span> 1.2.1 Counterparty Foundation
(2014-2023)</a></li>
<li><a href="#genesis-block-779652-march-29-2023"
id="toc-genesis-block-779652-march-29-2023"><span
class="toc-section-number">2.2.2</span> 1.2.2 Genesis: Block 779,652
(March 29, 2023)</a></li>
<li><a href="#cultural-milestone-kevin-blocks-783718-788041"
id="toc-cultural-milestone-kevin-blocks-783718-788041"><span
class="toc-section-number">2.2.3</span> 1.2.3 Cultural Milestone: KEVIN
(Blocks 783,718 &amp; 788,041)</a></li>
<li><a href="#technical-evolution-block-793068-april-20-2023"
id="toc-technical-evolution-block-793068-april-20-2023"><span
class="toc-section-number">2.2.4</span> 1.2.4 Technical Evolution: Block
793,068 (April 20, 2023)</a></li>
<li><a href="#asset-standards-blocks-788041---796000"
id="toc-asset-standards-blocks-788041---796000"><span
class="toc-section-number">2.2.5</span> 1.2.5 Asset Standards: Blocks
788,041 - 796,000</a></li>
<li><a href="#optimization-olga-at-block-865000-october-15-2023"
id="toc-optimization-olga-at-block-865000-october-15-2023"><span
class="toc-section-number">2.2.6</span> 1.2.6 Optimization: OLGA at
Block 865,000 (October 15, 2023)</a></li>
</ul></li>
<li><a href="#protocol-overview" id="toc-protocol-overview"><span
class="toc-section-number">2.3</span> 1.3 Protocol Overview</a></li>
<li><a href="#design-principles" id="toc-design-principles"><span
class="toc-section-number">2.4</span> 1.4 Design Principles</a></li>
<li><a href="#document-scope" id="toc-document-scope"><span
class="toc-section-number">2.5</span> 1.5 Document Scope</a></li>
<li><a href="#terminology" id="toc-terminology"><span
class="toc-section-number">2.6</span> 1.6 Terminology</a></li>
</ul></li>
<li><a href="#protocol-architecture"
id="toc-protocol-architecture"><span class="toc-section-number">3</span>
2. Protocol Architecture</a>
<ul>
<li><a href="#architectural-overview"
id="toc-architectural-overview"><span
class="toc-section-number">3.1</span> 2.1 Architectural
Overview</a></li>
<li><a href="#utxo-storage-model" id="toc-utxo-storage-model"><span
class="toc-section-number">3.2</span> 2.2 UTXO Storage Model</a>
<ul>
<li><a href="#bitcoin-utxo-set" id="toc-bitcoin-utxo-set"><span
class="toc-section-number">3.2.1</span> 2.2.1 Bitcoin UTXO Set</a></li>
<li><a href="#why-utxo-storage-guarantees-permanence"
id="toc-why-utxo-storage-guarantees-permanence"><span
class="toc-section-number">3.2.2</span> 2.2.2 Why UTXO Storage
Guarantees Permanence</a></li>
<li><a href="#utxo-set-size-implications"
id="toc-utxo-set-size-implications"><span
class="toc-section-number">3.2.3</span> 2.2.3 UTXO Set Size
Implications</a></li>
</ul></li>
<li><a href="#encoding-layer-architecture"
id="toc-encoding-layer-architecture"><span
class="toc-section-number">3.3</span> 2.3 Encoding Layer
Architecture</a>
<ul>
<li><a href="#bare-multisig-encoding-blocks-779652---865000"
id="toc-bare-multisig-encoding-blocks-779652---865000"><span
class="toc-section-number">3.3.1</span> 2.3.1 Bare Multisig Encoding
(Blocks 779,652 - 865,000)</a></li>
<li><a href="#p2wsholga-encoding-block-865000"
id="toc-p2wsholga-encoding-block-865000"><span
class="toc-section-number">3.3.2</span> 2.3.2 P2WSH/OLGA Encoding (Block
865,000+)</a></li>
<li><a href="#encoding-layer-comparison"
id="toc-encoding-layer-comparison"><span
class="toc-section-number">3.3.3</span> 2.3.3 Encoding Layer
Comparison</a></li>
</ul></li>
<li><a href="#account-based-asset-tracking"
id="toc-account-based-asset-tracking"><span
class="toc-section-number">3.4</span> 2.4 Account-Based Asset
Tracking</a>
<ul>
<li><a href="#the-account-model" id="toc-the-account-model"><span
class="toc-section-number">3.4.1</span> 2.4.1 The Account Model</a></li>
<li><a href="#asset-state-management"
id="toc-asset-state-management"><span
class="toc-section-number">3.4.2</span> 2.4.2 Asset State
Management</a></li>
<li><a href="#transfer-mechanism" id="toc-transfer-mechanism"><span
class="toc-section-number">3.4.3</span> 2.4.3 Transfer
Mechanism</a></li>
</ul></li>
<li><a href="#layer-separation" id="toc-layer-separation"><span
class="toc-section-number">3.5</span> 2.5 Layer Separation</a>
<ul>
<li><a href="#encoding-ownership" id="toc-encoding-ownership"><span
class="toc-section-number">3.5.1</span> 2.5.1 Encoding ≠
Ownership</a></li>
<li><a href="#standards-layer-flexibility"
id="toc-standards-layer-flexibility"><span
class="toc-section-number">3.5.2</span> 2.5.2 Standards Layer
Flexibility</a></li>
</ul></li>
<li><a href="#architecture-summary" id="toc-architecture-summary"><span
class="toc-section-number">3.6</span> 2.6 Architecture Summary</a></li>
</ul></li>
<li><a href="#token-standards" id="toc-token-standards"><span
class="toc-section-number">4</span> 4. Token Standards</a>
<ul>
<li><a href="#src-20-fungible-token-standard"
id="toc-src-20-fungible-token-standard"><span
class="toc-section-number">4.1</span> 4.1 SRC-20: Fungible Token
Standard</a>
<ul>
<li><a href="#overview" id="toc-overview"><span
class="toc-section-number">4.1.1</span> Overview</a></li>
<li><a href="#first-deployment" id="toc-first-deployment"><span
class="toc-section-number">4.1.2</span> First Deployment</a></li>
<li><a href="#transaction-structure"
id="toc-transaction-structure"><span
class="toc-section-number">4.1.3</span> Transaction Structure</a></li>
<li><a href="#operations" id="toc-operations"><span
class="toc-section-number">4.1.4</span> Operations</a></li>
<li><a href="#validation-and-indexing"
id="toc-validation-and-indexing"><span
class="toc-section-number">4.1.5</span> Validation and Indexing</a></li>
<li><a href="#economic-model" id="toc-economic-model"><span
class="toc-section-number">4.1.6</span> Economic Model</a></li>
</ul></li>
<li><a href="#src-721-layered-nft-standard"
id="toc-src-721-layered-nft-standard"><span
class="toc-section-number">4.2</span> 4.2 SRC-721: Layered NFT
Standard</a>
<ul>
<li><a href="#overview-1" id="toc-overview-1"><span
class="toc-section-number">4.2.1</span> Overview</a></li>
<li><a href="#architecture" id="toc-architecture"><span
class="toc-section-number">4.2.2</span> Architecture</a></li>
<li><a href="#benefits" id="toc-benefits"><span
class="toc-section-number">4.2.3</span> Benefits</a></li>
<li><a href="#transaction-fields" id="toc-transaction-fields"><span
class="toc-section-number">4.2.4</span> Transaction Fields</a></li>
<li><a href="#first-implementation" id="toc-first-implementation"><span
class="toc-section-number">4.2.5</span> First Implementation</a></li>
</ul></li>
<li><a href="#src-721r-recursive-rendering-standard"
id="toc-src-721r-recursive-rendering-standard"><span
class="toc-section-number">4.3</span> 4.3 SRC-721r: Recursive Rendering
Standard</a>
<ul>
<li><a href="#evolution-from-src-721"
id="toc-evolution-from-src-721"><span
class="toc-section-number">4.3.1</span> Evolution from SRC-721</a></li>
<li><a href="#technical-capabilities"
id="toc-technical-capabilities"><span
class="toc-section-number">4.3.2</span> Technical Capabilities</a></li>
<li><a href="#use-cases" id="toc-use-cases"><span
class="toc-section-number">4.3.3</span> Use Cases</a></li>
<li><a href="#security-considerations"
id="toc-security-considerations"><span
class="toc-section-number">4.3.4</span> Security Considerations</a></li>
</ul></li>
<li><a href="#src-101-domain-registration-standard"
id="toc-src-101-domain-registration-standard"><span
class="toc-section-number">4.4</span> 4.4 SRC-101: Domain Registration
Standard</a>
<ul>
<li><a href="#overview-2" id="toc-overview-2"><span
class="toc-section-number">4.4.1</span> Overview</a></li>
<li><a href="#core-design" id="toc-core-design"><span
class="toc-section-number">4.4.2</span> Core Design</a></li>
<li><a href="#operations-1" id="toc-operations-1"><span
class="toc-section-number">4.4.3</span> Operations</a></li>
<li><a href="#address-interoperability"
id="toc-address-interoperability"><span
class="toc-section-number">4.4.4</span> Address
Interoperability</a></li>
<li><a href="#economic-model-1" id="toc-economic-model-1"><span
class="toc-section-number">4.4.5</span> Economic Model</a></li>
</ul></li>
<li><a href="#cross-protocol-guarantees"
id="toc-cross-protocol-guarantees"><span
class="toc-section-number">4.5</span> 4.5 Cross-Protocol
Guarantees</a></li>
</ul></li>
<li><a href="#economic-model-2" id="toc-economic-model-2"><span
class="toc-section-number">5</span> 5. Economic Model</a>
<ul>
<li><a href="#utxo-set-permanence-guarantees"
id="toc-utxo-set-permanence-guarantees"><span
class="toc-section-number">5.1</span> 5.1 UTXO Set Permanence
Guarantees</a>
<ul>
<li><a href="#architectural-foundation"
id="toc-architectural-foundation"><span
class="toc-section-number">5.1.1</span> Architectural
Foundation</a></li>
<li><a href="#permanence-mechanism" id="toc-permanence-mechanism"><span
class="toc-section-number">5.1.2</span> Permanence Mechanism</a></li>
<li><a href="#economic-implications-of-permanence"
id="toc-economic-implications-of-permanence"><span
class="toc-section-number">5.1.3</span> Economic Implications of
Permanence</a></li>
</ul></li>
<li><a href="#storage-format-evolution"
id="toc-storage-format-evolution"><span
class="toc-section-number">5.2</span> 5.2 Storage Format Evolution</a>
<ul>
<li><a href="#bare-multisig-op_multisig"
id="toc-bare-multisig-op_multisig"><span
class="toc-section-number">5.2.1</span> Bare Multisig
(OP_MULTISIG)</a></li>
<li><a href="#p2wsh-migration" id="toc-p2wsh-migration"><span
class="toc-section-number">5.2.2</span> P2WSH Migration</a></li>
<li><a href="#olga-encoding" id="toc-olga-encoding"><span
class="toc-section-number">5.2.3</span> OLGA Encoding</a></li>
</ul></li>
<li><a href="#miner-fee-economics" id="toc-miner-fee-economics"><span
class="toc-section-number">5.3</span> 5.3 Miner Fee Economics</a>
<ul>
<li><a href="#fee-market-competition"
id="toc-fee-market-competition"><span
class="toc-section-number">5.3.1</span> Fee Market Competition</a></li>
<li><a href="#cost-structure-analysis"
id="toc-cost-structure-analysis"><span
class="toc-section-number">5.3.2</span> Cost Structure Analysis</a></li>
<li><a href="#miner-revenue-impact" id="toc-miner-revenue-impact"><span
class="toc-section-number">5.3.3</span> Miner Revenue Impact</a></li>
</ul></li>
<li><a href="#storage-cost-comparison"
id="toc-storage-cost-comparison"><span
class="toc-section-number">5.4</span> 5.4 Storage Cost Comparison</a>
<ul>
<li><a href="#bitcoin-stamps-vs.-ordinals"
id="toc-bitcoin-stamps-vs.-ordinals"><span
class="toc-section-number">5.4.1</span> Bitcoin Stamps
vs. Ordinals</a></li>
<li><a href="#utxo-set-growth-implications"
id="toc-utxo-set-growth-implications"><span
class="toc-section-number">5.4.2</span> UTXO Set Growth
Implications</a></li>
<li><a href="#alternative-protocols"
id="toc-alternative-protocols"><span
class="toc-section-number">5.4.3</span> Alternative Protocols</a></li>
</ul></li>
<li><a href="#economic-sustainability"
id="toc-economic-sustainability"><span
class="toc-section-number">5.5</span> 5.5 Economic Sustainability</a>
<ul>
<li><a href="#protocol-fee-structure"
id="toc-protocol-fee-structure"><span
class="toc-section-number">5.5.1</span> Protocol Fee Structure</a></li>
<li><a href="#miner-incentive-alignment"
id="toc-miner-incentive-alignment"><span
class="toc-section-number">5.5.2</span> Miner Incentive
Alignment</a></li>
<li><a href="#market-driven-equilibrium"
id="toc-market-driven-equilibrium"><span
class="toc-section-number">5.5.3</span> Market-Driven
Equilibrium</a></li>
</ul></li>
<li><a href="#economic-tradeoffs-summary"
id="toc-economic-tradeoffs-summary"><span
class="toc-section-number">5.6</span> 5.6 Economic Tradeoffs Summary</a>
<ul>
<li><a href="#advantages" id="toc-advantages"><span
class="toc-section-number">5.6.1</span> Advantages</a></li>
<li><a href="#disadvantages" id="toc-disadvantages"><span
class="toc-section-number">5.6.2</span> Disadvantages</a></li>
<li><a href="#strategic-positioning"
id="toc-strategic-positioning"><span
class="toc-section-number">5.6.3</span> Strategic Positioning</a></li>
</ul></li>
</ul></li>
<li><a href="#stamps-improvement-proposals-sips"
id="toc-stamps-improvement-proposals-sips"><span
class="toc-section-number">6</span> 6. Stamps Improvement Proposals
(SIPs)</a>
<ul>
<li><a href="#sip-governance-framework"
id="toc-sip-governance-framework"><span
class="toc-section-number">6.1</span> 6.1 SIP Governance Framework</a>
<ul>
<li><a href="#sip-lifecycle" id="toc-sip-lifecycle"><span
class="toc-section-number">6.1.1</span> 6.1.1 SIP Lifecycle</a></li>
<li><a href="#activation-lead-time" id="toc-activation-lead-time"><span
class="toc-section-number">6.1.2</span> 6.1.2 Activation Lead
Time</a></li>
<li><a href="#consensus-requirements"
id="toc-consensus-requirements"><span
class="toc-section-number">6.1.3</span> 6.1.3 Consensus
Requirements</a></li>
<li><a href="#github-issue-tracking"
id="toc-github-issue-tracking"><span
class="toc-section-number">6.1.4</span> 6.1.4 GitHub Issue
Tracking</a></li>
</ul></li>
<li><a href="#active-sips" id="toc-active-sips"><span
class="toc-section-number">6.2</span> 6.2 Active SIPs</a>
<ul>
<li><a href="#sip-0001-src-20-htlc-hash-time-locked-contracts"
id="toc-sip-0001-src-20-htlc-hash-time-locked-contracts"><span
class="toc-section-number">6.2.1</span> 6.2.1 SIP-0001: SRC-20 HTLC
(Hash Time-Locked Contracts)</a></li>
<li><a href="#sip-0003-cross-chain-bridges"
id="toc-sip-0003-cross-chain-bridges"><span
class="toc-section-number">6.2.2</span> 6.2.2 SIP-0003: Cross-Chain
Bridges</a></li>
<li><a href="#sip-0004-privacy-enhancements"
id="toc-sip-0004-privacy-enhancements"><span
class="toc-section-number">6.2.3</span> 6.2.3 SIP-0004: Privacy
Enhancements</a></li>
<li><a href="#sip-0005-binary-transfer-format-for-src-20"
id="toc-sip-0005-binary-transfer-format-for-src-20"><span
class="toc-section-number">6.2.4</span> 6.2.4 SIP-0005: Binary Transfer
Format for SRC-20</a></li>
<li><a href="#sip-0006-native-src-20-amm-automated-market-maker"
id="toc-sip-0006-native-src-20-amm-automated-market-maker"><span
class="toc-section-number">6.2.5</span> 6.2.5 SIP-0006: Native SRC-20
AMM (Automated Market Maker)</a></li>
<li><a
href="#sip-0008-dual-transaction-parsing-combined-src-20-transfer-stamp-issuance"
id="toc-sip-0008-dual-transaction-parsing-combined-src-20-transfer-stamp-issuance"><span
class="toc-section-number">6.2.6</span> 6.2.6 SIP-0008: Dual Transaction
Parsing — Combined SRC-20 Transfer + Stamp Issuance</a></li>
</ul></li>
<li><a href="#superseded-sips" id="toc-superseded-sips"><span
class="toc-section-number">6.3</span> 6.3 Superseded SIPs</a>
<ul>
<li><a href="#sip-0002-src-20-utxo-binding-transfer-format-v2.0"
id="toc-sip-0002-src-20-utxo-binding-transfer-format-v2.0"><span
class="toc-section-number">6.3.1</span> 6.3.1 SIP-0002: SRC-20 UTXO
Binding &amp; Transfer Format v2.0</a></li>
</ul></li>
<li><a href="#sip-process-best-practices"
id="toc-sip-process-best-practices"><span
class="toc-section-number">6.4</span> 6.4 SIP Process Best Practices</a>
<ul>
<li><a href="#proposal-template" id="toc-proposal-template"><span
class="toc-section-number">6.4.1</span> 6.4.1 Proposal Template</a></li>
<li><a href="#review-criteria" id="toc-review-criteria"><span
class="toc-section-number">6.4.2</span> 6.4.2 Review Criteria</a></li>
<li><a href="#implementation-requirements"
id="toc-implementation-requirements"><span
class="toc-section-number">6.4.3</span> 6.4.3 Implementation
Requirements</a></li>
</ul></li>
<li><a href="#open-research-areas" id="toc-open-research-areas"><span
class="toc-section-number">6.5</span> 6.5 Open Research Areas</a>
<ul>
<li><a href="#zero-knowledge-proofs"
id="toc-zero-knowledge-proofs"><span
class="toc-section-number">6.5.1</span> 6.5.1 Zero-Knowledge
Proofs</a></li>
<li><a href="#recursive-stamps-v2" id="toc-recursive-stamps-v2"><span
class="toc-section-number">6.5.2</span> 6.5.2 Recursive Stamps
v2</a></li>
<li><a href="#rollup-integration" id="toc-rollup-integration"><span
class="toc-section-number">6.5.3</span> 6.5.3 Rollup
Integration</a></li>
</ul></li>
<li><a href="#sip-summary-table" id="toc-sip-summary-table"><span
class="toc-section-number">6.6</span> 6.6 SIP Summary Table</a></li>
</ul></li>
<li><a href="#implementation" id="toc-implementation"><span
class="toc-section-number">7</span> 7. Implementation</a>
<ul>
<li><a href="#indexer-architecture" id="toc-indexer-architecture"><span
class="toc-section-number">7.1</span> 7.1 Indexer Architecture</a>
<ul>
<li><a href="#core-components" id="toc-core-components"><span
class="toc-section-number">7.1.1</span> 7.1.1 Core Components</a></li>
<li><a href="#block-processing-pipeline"
id="toc-block-processing-pipeline"><span
class="toc-section-number">7.1.2</span> 7.1.2 Block Processing
Pipeline</a></li>
<li><a href="#state-database-schema"
id="toc-state-database-schema"><span
class="toc-section-number">7.1.3</span> 7.1.3 State Database
Schema</a></li>
<li><a href="#reorganization-handling"
id="toc-reorganization-handling"><span
class="toc-section-number">7.1.4</span> 7.1.4 Reorganization
Handling</a></li>
</ul></li>
<li><a href="#consensus-model" id="toc-consensus-model"><span
class="toc-section-number">7.2</span> 7.2 Consensus Model</a>
<ul>
<li><a href="#deterministic-validation"
id="toc-deterministic-validation"><span
class="toc-section-number">7.2.1</span> 7.2.1 Deterministic
Validation</a></li>
<li><a href="#first-seen-rule" id="toc-first-seen-rule"><span
class="toc-section-number">7.2.2</span> 7.2.2 First-Seen Rule</a></li>
<li><a href="#consensus-checkpoints"
id="toc-consensus-checkpoints"><span
class="toc-section-number">7.2.3</span> 7.2.3 Consensus
Checkpoints</a></li>
<li><a href="#multi-indexer-consensus"
id="toc-multi-indexer-consensus"><span
class="toc-section-number">7.2.4</span> 7.2.4 Multi-Indexer
Consensus</a></li>
</ul></li>
<li><a href="#validation-logic" id="toc-validation-logic"><span
class="toc-section-number">7.3</span> 7.3 Validation Logic</a>
<ul>
<li><a href="#src-20-validation" id="toc-src-20-validation"><span
class="toc-section-number">7.3.1</span> 7.3.1 SRC-20 Validation</a></li>
<li><a href="#src-721-validation" id="toc-src-721-validation"><span
class="toc-section-number">7.3.2</span> 7.3.2 SRC-721
Validation</a></li>
<li><a href="#encoding-detection" id="toc-encoding-detection"><span
class="toc-section-number">7.3.3</span> 7.3.3 Encoding
Detection</a></li>
</ul></li>
<li><a href="#performance-optimization"
id="toc-performance-optimization"><span
class="toc-section-number">7.4</span> 7.4 Performance Optimization</a>
<ul>
<li><a href="#rust-parser-integration"
id="toc-rust-parser-integration"><span
class="toc-section-number">7.4.1</span> 7.4.1 Rust Parser
Integration</a></li>
<li><a href="#database-indexing" id="toc-database-indexing"><span
class="toc-section-number">7.4.2</span> 7.4.2 Database Indexing</a></li>
<li><a href="#caching-strategy" id="toc-caching-strategy"><span
class="toc-section-number">7.4.3</span> 7.4.3 Caching Strategy</a></li>
</ul></li>
<li><a href="#api-layer" id="toc-api-layer"><span
class="toc-section-number">7.5</span> 7.5 API Layer</a>
<ul>
<li><a href="#rest-endpoints" id="toc-rest-endpoints"><span
class="toc-section-number">7.5.1</span> 7.5.1 REST Endpoints</a></li>
<li><a href="#websocket-real-time-updates"
id="toc-websocket-real-time-updates"><span
class="toc-section-number">7.5.2</span> 7.5.2 WebSocket Real-Time
Updates</a></li>
</ul></li>
<li><a href="#implementation-summary"
id="toc-implementation-summary"><span
class="toc-section-number">7.6</span> 7.6 Implementation
Summary</a></li>
</ul></li>
<li><a href="#security-analysis" id="toc-security-analysis"><span
class="toc-section-number">8</span> 8. Security Analysis</a>
<ul>
<li><a href="#immutability-guarantees"
id="toc-immutability-guarantees"><span
class="toc-section-number">8.1</span> 8.1 Immutability Guarantees</a>
<ul>
<li><a href="#utxo-set-permanence" id="toc-utxo-set-permanence"><span
class="toc-section-number">8.1.1</span> 8.1.1 UTXO Set
Permanence</a></li>
<li><a href="#utxo-vs-witness-data" id="toc-utxo-vs-witness-data"><span
class="toc-section-number">8.1.2</span> 8.1.2 UTXO vs Witness
Data</a></li>
<li><a href="#utxo-spending-risk" id="toc-utxo-spending-risk"><span
class="toc-section-number">8.1.3</span> 8.1.3 UTXO Spending
Risk</a></li>
<li><a href="#consensus-layer-protection"
id="toc-consensus-layer-protection"><span
class="toc-section-number">8.1.4</span> 8.1.4 Consensus-Layer
Protection</a></li>
</ul></li>
<li><a href="#indexer-security-model"
id="toc-indexer-security-model"><span
class="toc-section-number">8.2</span> 8.2 Indexer Security Model</a>
<ul>
<li><a href="#trust-assumptions" id="toc-trust-assumptions"><span
class="toc-section-number">8.2.1</span> 8.2.1 Trust Assumptions</a></li>
<li><a href="#indexer-attack-vectors"
id="toc-indexer-attack-vectors"><span
class="toc-section-number">8.2.2</span> 8.2.2 Indexer Attack
Vectors</a></li>
<li><a href="#data-availability" id="toc-data-availability"><span
class="toc-section-number">8.2.3</span> 8.2.3 Data Availability</a></li>
</ul></li>
<li><a href="#protocol-specific-vulnerabilities"
id="toc-protocol-specific-vulnerabilities"><span
class="toc-section-number">8.3</span> 8.3 Protocol-Specific
Vulnerabilities</a>
<ul>
<li><a href="#front-running-attacks"
id="toc-front-running-attacks"><span
class="toc-section-number">8.3.1</span> 8.3.1 Front-Running
Attacks</a></li>
<li><a href="#replay-attacks" id="toc-replay-attacks"><span
class="toc-section-number">8.3.2</span> 8.3.2 Replay Attacks</a></li>
<li><a href="#ticker-squatting" id="toc-ticker-squatting"><span
class="toc-section-number">8.3.3</span> 8.3.3 Ticker Squatting</a></li>
<li><a href="#dust-attack" id="toc-dust-attack"><span
class="toc-section-number">8.3.4</span> 8.3.4 Dust Attack</a></li>
</ul></li>
<li><a href="#attack-cost-analysis" id="toc-attack-cost-analysis"><span
class="toc-section-number">8.4</span> 8.4 Attack Cost Analysis</a>
<ul>
<li><a href="#stamp-reversal-attack"
id="toc-stamp-reversal-attack"><span
class="toc-section-number">8.4.1</span> 8.4.1 Stamp Reversal
Attack</a></li>
<li><a href="#indexer-manipulation-attack"
id="toc-indexer-manipulation-attack"><span
class="toc-section-number">8.4.2</span> 8.4.2 Indexer Manipulation
Attack</a></li>
<li><a href="#ticker-squatting-attack"
id="toc-ticker-squatting-attack"><span
class="toc-section-number">8.4.3</span> 8.4.3 Ticker Squatting
Attack</a></li>
</ul></li>
<li><a href="#threat-model-summary" id="toc-threat-model-summary"><span
class="toc-section-number">8.5</span> 8.5 Threat Model Summary</a>
<ul>
<li><a href="#security-hierarchy" id="toc-security-hierarchy"><span
class="toc-section-number">8.5.1</span> 8.5.1 Security
Hierarchy</a></li>
<li><a href="#risk-matrix" id="toc-risk-matrix"><span
class="toc-section-number">8.5.2</span> 8.5.2 Risk Matrix</a></li>
<li><a href="#security-recommendations"
id="toc-security-recommendations"><span
class="toc-section-number">8.5.3</span> 8.5.3 Security
Recommendations</a></li>
</ul></li>
<li><a href="#comparison-with-other-protocols"
id="toc-comparison-with-other-protocols"><span
class="toc-section-number">8.6</span> 8.6 Comparison with Other
Protocols</a>
<ul>
<li><a href="#bitcoin-stamps-vs-ordinals"
id="toc-bitcoin-stamps-vs-ordinals"><span
class="toc-section-number">8.6.1</span> 8.6.1 Bitcoin Stamps vs
Ordinals</a></li>
<li><a href="#bitcoin-stamps-vs-counterparty"
id="toc-bitcoin-stamps-vs-counterparty"><span
class="toc-section-number">8.6.2</span> 8.6.2 Bitcoin Stamps vs
Counterparty</a></li>
</ul></li>
<li><a href="#future-security-considerations"
id="toc-future-security-considerations"><span
class="toc-section-number">8.7</span> 8.7 Future Security
Considerations</a>
<ul>
<li><a href="#quantum-computing-threat"
id="toc-quantum-computing-threat"><span
class="toc-section-number">8.7.1</span> 8.7.1 Quantum Computing
Threat</a></li>
<li><a href="#bitcoin-protocol-changes"
id="toc-bitcoin-protocol-changes"><span
class="toc-section-number">8.7.2</span> 8.7.2 Bitcoin Protocol
Changes</a></li>
<li><a href="#regulatory-challenges"
id="toc-regulatory-challenges"><span
class="toc-section-number">8.7.3</span> 8.7.3 Regulatory
Challenges</a></li>
</ul></li>
</ul></li>
<li><a href="#future-work" id="toc-future-work"><span
class="toc-section-number">9</span> 9. Future Work</a>
<ul>
<li><a href="#active-sip-proposals" id="toc-active-sip-proposals"><span
class="toc-section-number">9.1</span> 9.1 Active SIP Proposals</a></li>
<li><a href="#research-directions" id="toc-research-directions"><span
class="toc-section-number">9.2</span> 9.2 Research Directions</a>
<ul>
<li><a href="#defi-primitives" id="toc-defi-primitives"><span
class="toc-section-number">9.2.1</span> DeFi Primitives</a></li>
<li><a href="#privacy" id="toc-privacy"><span
class="toc-section-number">9.2.2</span> Privacy</a></li>
<li><a href="#cross-chain-bridges" id="toc-cross-chain-bridges"><span
class="toc-section-number">9.2.3</span> Cross-Chain Bridges</a></li>
<li><a href="#protocol-optimizations"
id="toc-protocol-optimizations"><span
class="toc-section-number">9.2.4</span> Protocol Optimizations</a></li>
</ul></li>
<li><a href="#design-principles-1" id="toc-design-principles-1"><span
class="toc-section-number">9.3</span> 9.3 Design Principles</a></li>
<li><a href="#long-term-vision" id="toc-long-term-vision"><span
class="toc-section-number">9.4</span> 9.4 Long-Term Vision</a></li>
</ul></li>
</ul>
</nav>
<h1 data-number="1" id="version-history"><span
class="header-section-number">1</span> Version History</h1>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 21%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Version</th>
<th>Date</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1.0</td>
<td>2026-02-16</td>
<td>Current release — factual corrections, OLGA clarifications,
condensed future roadmap</td>
</tr>
<tr class="even">
<td style="text-align: center;">0.9</td>
<td>2026-02-16</td>
<td>Initial whitepaper draft — full protocol specification</td>
</tr>
<tr class="odd">
<td style="text-align: center;">—</td>
<td>March 29, 2023</td>
<td>Protocol genesis — first Bitcoin Stamp at block 779,652</td>
</tr>
</tbody>
</table>
<hr />
<h1 data-number="2" id="introduction"><span
class="header-section-number">2</span> 1. Introduction</h1>
<h2 data-number="2.1" id="motivation"><span
class="header-section-number">2.1</span> 1.1 Motivation</h2>
<p>Bitcoin’s primary innovation is permanent, censorship-resistant value
storage backed by proof-of-work consensus. While Bitcoin enables
programmable transactions through Script, the network primarily serves
as monetary infrastructure. Bitcoin Stamps extends this permanence to
arbitrary data—images, tokens, names—by embedding information directly
in Bitcoin’s UTXO set.</p>
<p><strong>Core Problem</strong>: Digital assets require permanent
storage to retain value. Traditional NFT platforms rely on IPFS,
Arweave, or centralized servers—all subject to failure modes outside
asset holders’ control. Even Bitcoin-based solutions using witness data
lack permanence guarantees since nodes can prune witness segments after
validation.</p>
<p><strong>Solution</strong>: Store asset data in transaction outputs
(UTXOs) rather than witness data or external systems. Bitcoin’s
consensus rules require all full nodes to maintain the UTXO set for
transaction validation, making UTXO-embedded data:</p>
<ul>
<li><strong>Consensus-critical</strong>: Required for network
operation</li>
<li><strong>Unprunable</strong>: Cannot be removed without breaking
validation</li>
<li><strong>Universal</strong>: Stored by every full node globally</li>
<li><strong>Permanent</strong>: Survives as long as Bitcoin exists</li>
</ul>
<p><strong>Design Philosophy</strong>: Embrace Bitcoin’s constraints
rather than fight them. Higher fees for UTXO storage reflect true
economic cost of permanent Bitcoin storage. Protocol design prioritizes
permanence over convenience, aligning with Bitcoin’s long-term value
proposition.</p>
<h2 data-number="2.2" id="historical-context"><span
class="header-section-number">2.2</span> 1.2 Historical Context</h2>
<h3 data-number="2.2.1" id="counterparty-foundation-2014-2023"><span
class="header-section-number">2.2.1</span> 1.2.1 Counterparty Foundation
(2014-2023)</h3>
<p>Bitcoin Stamps builds on Counterparty protocol, established January
2014 as Bitcoin’s first metaprotocol for asset creation. Counterparty
introduced:</p>
<ul>
<li><strong>Account-based assets</strong>: Balance ledger tracked per
address, not per UTXO</li>
<li><strong>OP_RETURN encoding</strong>: Embed metadata in 80-byte
provably unspendable outputs</li>
<li><strong>Decentralized exchange</strong>: On-chain order books and
atomic swaps</li>
<li><strong>10+ years production</strong>: Battle-tested architecture
handling millions of transactions</li>
</ul>
<p>Counterparty proved account-based asset tracking works at scale on
Bitcoin. Rather than track which UTXOs contain tokens (complex,
privacy-leaking), maintain address-level balances (simple, efficient,
private).</p>
<p><strong>Critical insight</strong>: SRC-20 tokens inherit
Counterparty’s account model. Token ownership is tracked per address in
indexer state, NOT embedded in specific UTXOs. This is foundational to
Bitcoin Stamps architecture.</p>
<h3 data-number="2.2.2" id="genesis-block-779652-march-29-2023"><span
class="header-section-number">2.2.2</span> 1.2.2 Genesis: Block 779,652
(March 29, 2023)</h3>
<p>Mikeinspace created the first Bitcoin Stamp—a laser-eyes pixel art
embedded via Counterparty transaction. This stamp used traditional
OP_RETURN encoding but sparked recognition: Bitcoin could permanently
store visual art, not just monetary metadata.</p>
<p><strong>Innovation</strong>: Frame digital art as permanent Bitcoin
artifacts rather than ephemeral files. If art data lives in Bitcoin’s
UTXO set, it inherits Bitcoin’s permanence and censorship
resistance.</p>
<p><strong>Community formation</strong>: The Original Trinity
(Mikeinspace, Arwyn, Reinamora) recognized potential for permanent
digital culture on Bitcoin. Within days, Stampchain.io launched as
reference indexer and minting interface, establishing infrastructure for
ecosystem growth.</p>
<h3 data-number="2.2.3"
id="cultural-milestone-kevin-blocks-783718-788041"><span
class="header-section-number">2.2.3</span> 1.2.3 Cultural Milestone:
KEVIN (Blocks 783,718 &amp; 788,041)</h3>
<p><strong>Block 783,718</strong> (March 15, 2023): Arwyn created KEVIN
(Stamp #4258) as homage to Rare Pepe culture. The artwork unexpectedly
exhibited “ghost-like” behavior—appearing in unexpected system
locations, inspiring organic derivative works. KEVIN evolved from
artistic experiment to community symbol.</p>
<p><strong>Block 788,041</strong> (April 20, 2023): Arwyn deployed KEVIN
as first SRC-20 token (Stamp #18,516), formalizing fungible token
standard atop Bitcoin Stamps. This dual nature (unique stamp #4258 +
fungible token) established pattern: stamps provide non-fungible
foundation, SRC-20 adds fungible layer.</p>
<p><strong>Cultural impact</strong>: KEVIN demonstrated fair launch
principles—no pre-mine, equal minting access, community-driven
distribution. These values became protocol philosophy: “we are all
Kevin” (echoing Mayan “In Lak’ech Ala K’in”—“I am you, you are me”).
Over 2,300 holders grew organically without marketing or
speculation.</p>
<h3 data-number="2.2.4"
id="technical-evolution-block-793068-april-20-2023"><span
class="header-section-number">2.2.4</span> 1.2.4 Technical Evolution:
Block 793,068 (April 20, 2023)</h3>
<p>First stamp using native Bitcoin bare multisig encoding rather than
Counterparty OP_RETURN. This transition marked protocol
independence—stamps no longer required Counterparty infrastructure, only
Bitcoin itself.</p>
<p><strong>Bare multisig encoding</strong>:</p>
<pre><code>OP_1 &lt;pubkey1&gt; &lt;pubkey2&gt; &lt;pubkey3&gt; OP_3 OP_CHECKMULTISIG</code></pre>
<p>Each “pubkey” is 32 bytes of image/data. A 2-of-3 multisig provides
64 bytes usable data per output. Multiple outputs chain together for
larger assets.</p>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Direct Bitcoin encoding without metaprotocol dependencies</li>
<li>UTXO-based storage (consensus-critical, unprunable)</li>
<li>No witness data—data is part of transaction validation itself</li>
<li>Simplified indexer logic (scan multisig outputs, decode data)</li>
</ul>
<p><strong>Tradeoffs</strong>: Higher fees (4x witness discount lost)
but guaranteed permanence. Design choice: pay for true permanence rather
than optimize for cost.</p>
<h3 data-number="2.2.5"
id="asset-standards-blocks-788041---796000"><span
class="header-section-number">2.2.5</span> 1.2.5 Asset Standards: Blocks
788,041 - 796,000</h3>
<p><strong>SRC-20 fungible tokens</strong> (block 788,041): JSON
metadata in stamp encoding defines DEPLOY, MINT, TRANSFER operations.
Indexers maintain account balances per Counterparty model—ownership
tracked by address, not UTXO.</p>
<p><strong>SRC-721 recursion</strong> (block 792,370): Stamps can
reference other stamps by ID, enabling composable artwork. A stamp might
combine background #1234 + character #5678 + effects #9012, creating
infinite combinations from finite on-chain components.</p>
<p><strong>Counterparty cutoff</strong> (block 796,000): Community
consensus rule—SRC-20 tokens on Counterparty only valid until block
796,000. After this, only Bitcoin-native encoded tokens recognized.
Ensures protocol independence while honoring early adopters.</p>
<h3 data-number="2.2.6"
id="optimization-olga-at-block-865000-october-15-2023"><span
class="header-section-number">2.2.6</span> 1.2.6 Optimization: OLGA at
Block 865,000 (October 15, 2023)</h3>
<p>Reinamora introduced OLGA (Octet Linked Graphical Artifacts)—P2WSH
encoding replacing bare multisig for 30-95% cost reduction.</p>
<p><strong>P2WSH structure</strong>:</p>
<pre><code>OP_0 &lt;32-byte-hash-of-witness-script&gt;</code></pre>
<p>Witness script contains data, hashed and stored in output. More
efficient than bare multisig pubkeys in output scripts.</p>
<p><strong>Key insight</strong>: P2WSH witness scripts are still
consensus-critical (unlike witness data for signatures). Scripts must be
provided to spend P2WSH outputs, so nodes must store them for UTXO
validation. Data remains unprunable and permanent.</p>
<p><strong>Cost reduction mechanism</strong>:</p>
<ul>
<li>Bare multisig: 3 fake pubkeys (96 bytes) per output in transaction
data</li>
<li>P2WSH: 32-byte hash per output, actual data in witness script</li>
<li>Witness discount: 4:1 reduction (witness data counted at 1/4
weight)</li>
<li>Result: 60-80% fee reduction for typical stamps</li>
</ul>
<p><strong>OLGA benefits</strong>:</p>
<ul>
<li>Maintains UTXO permanence (witness scripts are
consensus-critical)</li>
<li>Dramatically reduces creation costs (broader accessibility)</li>
<li>Better miner priority (more efficient byte usage)</li>
<li>Universal compatibility (works across all stamp protocols)</li>
</ul>
<h2 data-number="2.3" id="protocol-overview"><span
class="header-section-number">2.3</span> 1.3 Protocol Overview</h2>
<p>Bitcoin Stamps protocol comprises:</p>
<ol type="1">
<li><strong>Data encoding layer</strong>: Bare multisig (pre-865,000) or
P2WSH/OLGA (post-865,000) for embedding data in UTXOs</li>
<li><strong>Asset tracking layer</strong>: Account-based ledger
(Counterparty-style) for ownership and balances</li>
<li><strong>Standards layer</strong>: SRC-20 (tokens), SRC-721
(recursion), SRC-101 (names) defining asset semantics</li>
<li><strong>Indexer layer</strong>: Software parsing stamp transactions,
maintaining asset state, serving APIs</li>
</ol>
<p><strong>Critical distinction</strong>: Encoding determines WHERE data
is stored (UTXOs). Asset tracking determines WHO owns WHAT (accounts).
These layers are independent—SRC-20 tokens use UTXO storage for
transaction permanence but account balances for ownership tracking.</p>
<h2 data-number="2.4" id="design-principles"><span
class="header-section-number">2.4</span> 1.4 Design Principles</h2>
<p><strong>Permanence over cost</strong>: Pay Bitcoin’s true storage
cost rather than rely on prunable witness data or external systems.
Expensive stamps reflect accurate economics of permanent Bitcoin
storage.</p>
<p><strong>Simplicity over features</strong>: Account-based assets
simpler than UTXO-bound tokens. Proven Counterparty model beats novel
approaches requiring complex state tracking.</p>
<p><strong>Bitcoin-native alignment</strong>: Work with Bitcoin’s
economic incentives (UTXO storage fees support miners) rather than fight
them (clever witness hacks ultimately prunable).</p>
<p><strong>Community governance</strong>: Fair launches (no pre-mines),
organic growth (no VC funding), cultural values (authenticity over
speculation). KEVIN’s success demonstrates aligned incentives create
sustainable ecosystems.</p>
<p><strong>Extensibility</strong>: Base stamp protocol provides
permanence primitive. Standards like SRC-20/721/101 add semantics
without modifying underlying encoding. Future protocols can leverage
same UTXO permanence.</p>
<h2 data-number="2.5" id="document-scope"><span
class="header-section-number">2.5</span> 1.5 Document Scope</h2>
<p>This whitepaper specifies:</p>
<ul>
<li>UTXO storage architecture and data encoding — bare multisig and
P2WSH/OLGA (Section 2)</li>
<li>Token standards — SRC-20, SRC-721, SRC-101 (Section 3)</li>
<li>Economic model (Section 4)</li>
<li>Stamps Improvement Proposals / SIP governance (Section 5)</li>
<li>Implementation guidelines (Section 6)</li>
<li>Security analysis (Section 7)</li>
<li>Future work and research directions (Section 8)</li>
</ul>
<p><strong>Out of scope</strong>: Wallet integration details, specific
indexer implementations, user interface design, market dynamics. Focus
is protocol specification for implementers.</p>
<h2 data-number="2.6" id="terminology"><span
class="header-section-number">2.6</span> 1.6 Terminology</h2>
<ul>
<li><strong>Stamp</strong>: Non-fungible digital asset permanently
stored in Bitcoin UTXO set via bare multisig or P2WSH encoding</li>
<li><strong>SRC-20</strong>: Fungible token standard atop stamps, using
account-based balance tracking</li>
<li><strong>UTXO set</strong>: Set of all unspent transaction outputs in
Bitcoin; consensus-critical data structure required for transaction
validation</li>
<li><strong>Account-based</strong>: Asset ownership tracked per address
(account balance) rather than per UTXO (UTXO-bound tokens)</li>
<li><strong>Bare multisig</strong>: Native Bitcoin multisig scripts used
to encode data in fake pubkeys</li>
<li><strong>P2WSH/OLGA</strong>: Pay-to-Witness-Script-Hash outputs
storing data in witness scripts (consensus-critical but
weight-discounted)</li>
<li><strong>Counterparty</strong>: First Bitcoin metaprotocol (est.
2014); provides account-based asset model inherited by Bitcoin
Stamps</li>
<li><strong>Indexer</strong>: Software parsing stamp transactions from
Bitcoin blockchain, maintaining asset state database, serving API
queries</li>
</ul>
<hr />
<h1 data-number="3" id="protocol-architecture"><span
class="header-section-number">3</span> 2. Protocol Architecture</h1>
<h2 data-number="3.1" id="architectural-overview"><span
class="header-section-number">3.1</span> 2.1 Architectural Overview</h2>
<p>Bitcoin Stamps employs a layered architecture separating
concerns:</p>
<pre><code>┌─────────────────────────────────────────────────────────┐
│                 APPLICATION LAYER                        │
│  Wallets, Explorers, Minting Interfaces, DEX Protocols  │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────┐
│                  STANDARDS LAYER                         │
│     SRC-20 (Tokens)  │  SRC-721 (Recursion)  │  SRC-101 │
│                     (Names)                              │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────┐
│                 ASSET TRACKING LAYER                     │
│        Account-based Ledger (Counterparty Model)         │
│   Address Balances, Ownership State, Transfer History   │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────┐
│                  ENCODING LAYER                          │
│   Bare Multisig (Pre-865k)  │  P2WSH/OLGA (Post-865k)  │
│           Data → Bitcoin Transaction Outputs             │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────┐
│                  STORAGE LAYER                           │
│                Bitcoin UTXO Set                          │
│      Consensus-Critical, Unprunable, Universal           │
└─────────────────────────────────────────────────────────┘</code></pre>
<p><strong>Key architectural principle</strong>: Data encoding (UTXO
storage) is independent from asset tracking (account balances). Stamps
permanently embed transaction data in Bitcoin outputs while maintaining
ownership through account ledger.</p>
<h2 data-number="3.2" id="utxo-storage-model"><span
class="header-section-number">3.2</span> 2.2 UTXO Storage Model</h2>
<h3 data-number="3.2.1" id="bitcoin-utxo-set"><span
class="header-section-number">3.2.1</span> 2.2.1 Bitcoin UTXO Set</h3>
<p>Bitcoin maintains an <strong>Unspent Transaction Output (UTXO)
set</strong>—the complete list of all unspent outputs on the blockchain.
This set is:</p>
<ul>
<li><strong>Consensus-critical</strong>: Required for validating new
transactions (ensure inputs reference valid UTXOs)</li>
<li><strong>Universal</strong>: Every full node maintains identical UTXO
set</li>
<li><strong>Unprunable</strong>: Cannot be deleted without breaking
transaction validation</li>
<li><strong>Permanent</strong>: Persists as long as Bitcoin network
operates</li>
</ul>
<p><strong>UTXO structure</strong>:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> UTXO <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    txid<span class="op">:</span> [<span class="dt">u8</span><span class="op">;</span> <span class="dv">32</span>]<span class="op">,</span>           <span class="co">// Transaction ID</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    vout<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span>                <span class="co">// Output index</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    amount<span class="op">:</span> <span class="dt">u64</span><span class="op">,</span>              <span class="co">// Satoshis</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    scriptPubKey<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;,</span>    <span class="co">// Locking script</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    height<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span>              <span class="co">// Block height</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Validation requirement</strong>: To validate a transaction
spending UTXO X, nodes must: 1. Verify X exists in UTXO set 2. Check
spending transaction provides valid unlock script 3. Verify amount
conservation (inputs ≥ outputs + fees) 4. Execute output scripts to
verify spending conditions</p>
<p><strong>Critical insight</strong>: Any data embedded in
<code>scriptPubKey</code> must be stored by all nodes to validate future
spends. This makes UTXO-embedded data consensus-critical and
unprunable.</p>
<h3 data-number="3.2.2"
id="why-utxo-storage-guarantees-permanence"><span
class="header-section-number">3.2.2</span> 2.2.2 Why UTXO Storage
Guarantees Permanence</h3>
<p>Contrast with witness data (SegWit):</p>
<p><strong>Witness data</strong> (signatures, witness scripts):</p>
<ul>
<li>Required only during transaction validation</li>
<li>After validation, nodes can prune witness data</li>
<li>Not part of transaction hash (malleability fix)</li>
<li>Not consensus-critical for future transactions</li>
<li><strong>Result</strong>: Witness data is prunable, not guaranteed
permanent</li>
</ul>
<p><strong>UTXO data</strong> (scriptPubKey, amounts):</p>
<ul>
<li>Required for all future transaction validation</li>
<li>Cannot be pruned without breaking validation</li>
<li>Part of transaction hash (UTXO uniquely identified by
txid:vout)</li>
<li>Consensus-critical for network operation</li>
<li><strong>Result</strong>: UTXO data is unprunable, guaranteed
permanent</li>
</ul>
<p><strong>Bitcoin Stamps strategy</strong>: Embed asset data in
scriptPubKey (output scripts) rather than witness data. This makes stamp
data UTXO-embedded and thus consensus-critical.</p>
<h3 data-number="3.2.3" id="utxo-set-size-implications"><span
class="header-section-number">3.2.3</span> 2.2.3 UTXO Set Size
Implications</h3>
<p>UTXO storage has real cost—every full node stores entire UTXO set in
fast-access databases. As of 2026:</p>
<ul>
<li>~150M UTXOs globally (~6GB UTXO database)</li>
<li>Each stamp adds 1-20 UTXOs depending on data size</li>
<li>Trade-off: Higher fees for permanent storage vs lower fees for
prunable witness data</li>
</ul>
<p><strong>Design philosophy</strong>: Accept higher costs for true
permanence. Bitcoin Stamps reflects accurate economics of permanent
Bitcoin storage. Protocols using witness data or external storage have
hidden costs (pruning risk, service maintenance, infrastructure
failure).</p>
<h2 data-number="3.3" id="encoding-layer-architecture"><span
class="header-section-number">3.3</span> 2.3 Encoding Layer
Architecture</h2>
<h3 data-number="3.3.1"
id="bare-multisig-encoding-blocks-779652---865000"><span
class="header-section-number">3.3.1</span> 2.3.1 Bare Multisig Encoding
(Blocks 779,652 - 865,000)</h3>
<p><strong>Structure</strong>: Use Bitcoin’s native multisig scripts to
encode data.</p>
<p><strong>Multisig script format</strong>:</p>
<pre><code>OP_1 &lt;pubkey1&gt; &lt;pubkey2&gt; &lt;pubkey3&gt; OP_3 OP_CHECKMULTISIG</code></pre>
<p><strong>Data encoding</strong>:</p>
<ul>
<li><code>&lt;pubkey1&gt;</code>, <code>&lt;pubkey2&gt;</code>,
<code>&lt;pubkey3&gt;</code> are 33-byte compressed pubkey format</li>
<li>Actually contain stamp data, not real public keys</li>
<li>2-of-3 multisig: keys 1 &amp; 2 are data (66 bytes), key 3 is real
signing key</li>
<li>Multiple outputs chained for larger data</li>
</ul>
<p><strong>Example</strong> (simplified):</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Encode 64 bytes of image data in bare multisig</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>output_script <span class="op">=</span> OP_1 <span class="op">+</span> data[<span class="dv">0</span>:<span class="dv">33</span>] <span class="op">+</span> data[<span class="dv">33</span>:<span class="dv">66</span>] <span class="op">+</span> real_pubkey <span class="op">+</span> OP_3 <span class="op">+</span> OP_CHECKMULTISIG</span></code></pre></div>
<p><strong>Characteristics</strong>:</p>
<ul>
<li><strong>Permanent</strong>: Data in scriptPubKey, part of UTXO
set</li>
<li><strong>Consensus-critical</strong>: Required to spend multisig
UTXO</li>
<li><strong>Expensive</strong>: Full transaction weight (4 WU per
byte)</li>
<li><strong>Simple</strong>: Native Bitcoin scripts, no special
rules</li>
<li><strong>Universal</strong>: Any Bitcoin node can validate</li>
</ul>
<p><strong>Limitations</strong>:</p>
<ul>
<li>High fees due to no witness discount</li>
<li>Large stamps require many outputs (cost scales linearly)</li>
<li>Multisig scripts flagged by some mempool policies (relay
issues)</li>
</ul>
<h3 data-number="3.3.2" id="p2wsholga-encoding-block-865000"><span
class="header-section-number">3.3.2</span> 2.3.2 P2WSH/OLGA Encoding
(Block 865,000+)</h3>
<p><strong>OLGA</strong> (Octet Linked Graphical Artifacts) uses
Pay-to-Witness-Script-Hash for 30-95% cost reduction.</p>
<p><strong>Structure</strong>:</p>
<pre><code>Output script: OP_0 &lt;32-byte-script-hash&gt;
Witness: &lt;actual-witness-script&gt;</code></pre>
<p><strong>Data encoding</strong>:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Encode data in P2WSH witness script</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>witness_script <span class="op">=</span> data_chunks <span class="op">+</span> OP_DROP_sequence <span class="op">+</span> <span class="op">&lt;</span>conditions<span class="op">&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>script_hash <span class="op">=</span> SHA256(witness_script)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>output_script <span class="op">=</span> OP_0 <span class="op">+</span> script_hash</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co"># To spend: provide witness_script in witness field</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>witness <span class="op">=</span> [signatures, witness_script]</span></code></pre></div>
<p><strong>Witness script construction</strong>:</p>
<pre><code>&lt;data_chunk_1&gt; OP_DROP &lt;data_chunk_2&gt; OP_DROP ... &lt;signature_check&gt;</code></pre>
<p>Data chunks are pushed to stack and dropped, leaving only signature
verification logic.</p>
<p><strong>Characteristics</strong>:</p>
<ul>
<li><strong>Still consensus-critical</strong>: Witness script must be
provided to spend P2WSH output</li>
<li><strong>Weight discount</strong>: Witness data counted at 1/4 weight
(WU)</li>
<li><strong>Cost reduction</strong>: 30-95% vs bare multisig</li>
<li><strong>Same permanence</strong>: Witness scripts stored in UTXO set
(not prunable)</li>
<li><strong>Better relay</strong>: P2WSH is standard, no mempool policy
issues</li>
</ul>
<p><strong>Key distinction</strong>: P2WSH witness <em>scripts</em>
(containing data) are consensus-critical, unlike witness
<em>signatures</em> (prunable). To spend P2WSH output, validator must:
1. Hash provided witness script 2. Compare to hash in output script 3.
Execute witness script 4. Verify conditions satisfied</p>
<p><strong>Result</strong>: Witness scripts cannot be pruned—required
for validation. Stamp data embedded in witness scripts remains permanent
and unprunable.</p>
<h3 data-number="3.3.3" id="encoding-layer-comparison"><span
class="header-section-number">3.3.3</span> 2.3.3 Encoding Layer
Comparison</h3>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 39%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th>Dimension</th>
<th>Bare Multisig</th>
<th>P2WSH/OLGA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Permanence</strong></td>
<td>✅ UTXO-embedded</td>
<td>✅ UTXO-embedded (witness script)</td>
</tr>
<tr class="even">
<td><strong>Consensus-critical</strong></td>
<td>✅ Yes</td>
<td>✅ Yes (script hash validation)</td>
</tr>
<tr class="odd">
<td><strong>Prunable</strong></td>
<td>❌ No</td>
<td>❌ No (scripts required for spending)</td>
</tr>
<tr class="even">
<td><strong>Cost</strong></td>
<td>High (4 WU/byte)</td>
<td>Low (1 WU/byte witness)</td>
</tr>
<tr class="odd">
<td><strong>Relay</strong></td>
<td>Potential issues</td>
<td>✅ Standard P2WSH</td>
</tr>
<tr class="even">
<td><strong>Complexity</strong></td>
<td>Simple</td>
<td>Moderate (witness construction)</td>
</tr>
<tr class="odd">
<td><strong>Block range</strong></td>
<td>779,652 - present</td>
<td>865,000 - present</td>
</tr>
</tbody>
</table>
<p><strong>Protocol evolution</strong>: OLGA doesn’t replace bare
multisig—both remain valid. Stamps can use either encoding; indexers
must support both. OLGA is optimization, not consensus change.</p>
<h2 data-number="3.4" id="account-based-asset-tracking"><span
class="header-section-number">3.4</span> 2.4 Account-Based Asset
Tracking</h2>
<h3 data-number="3.4.1" id="the-account-model"><span
class="header-section-number">3.4.1</span> 2.4.1 The Account Model</h3>
<p><strong>Critical architectural decision</strong>: Bitcoin Stamps uses
<strong>account-based</strong> asset tracking, NOT UTXO-based.</p>
<p><strong>Account-based</strong> (Bitcoin Stamps, Counterparty):</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># State: simple address → balance mapping</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>balances <span class="op">=</span> {</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;bc1q...xyz&quot;</span>: {<span class="st">&quot;KEVIN&quot;</span>: <span class="dv">1000</span>, <span class="st">&quot;STAMP&quot;</span>: <span class="dv">50</span>},</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;bc1q...abc&quot;</span>: {<span class="st">&quot;KEVIN&quot;</span>: <span class="dv">500</span>}</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Transfer: update sender and receiver balances</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transfer(from_addr, to_addr, asset, amount):</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    balances[from_addr][asset] <span class="op">-=</span> amount</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    balances[to_addr][asset] <span class="op">+=</span> amount</span></code></pre></div>
<p><strong>UTXO-based</strong> (Colored Coins, theoretical models):</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># State: track which UTXOs contain which tokens</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>token_utxos <span class="op">=</span> {</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;txid1:vout0&quot;</span>: {<span class="st">&quot;asset&quot;</span>: <span class="st">&quot;TOKEN&quot;</span>, <span class="st">&quot;amount&quot;</span>: <span class="dv">100</span>},</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;txid2:vout1&quot;</span>: {<span class="st">&quot;asset&quot;</span>: <span class="st">&quot;TOKEN&quot;</span>, <span class="st">&quot;amount&quot;</span>: <span class="dv">200</span>}</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Transfer: complicated UTXO tracking across inputs/outputs</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transfer(tx):</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    input_tokens <span class="op">=</span> <span class="bu">sum</span>(token_utxos[<span class="bu">input</span>] <span class="cf">for</span> <span class="bu">input</span> <span class="kw">in</span> tx.inputs)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Allocate to outputs (complex rules for multi-input, change, fees)</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    distribute_to_outputs(tx.outputs, input_tokens)</span></code></pre></div>
<p><strong>Why account-based wins</strong>:</p>
<ol type="1">
<li><strong>Simplicity</strong>: Address balances simpler than UTXO
tracking across coin mixing</li>
<li><strong>Privacy</strong>: Don’t reveal which specific coins hold
tokens</li>
<li><strong>Efficiency</strong>: Single DB query for balance vs scanning
UTXO set</li>
<li><strong>Proven</strong>: Counterparty ran 10+ years on account
model</li>
<li><strong>UX</strong>: Users understand “address balance” better than
“token-bearing UTXO”</li>
</ol>
<p><strong>Common misconception</strong>: “SRC-20 tokens are locked in
UTXOs.” <strong>False</strong>. SRC-20 balances are tracked per address
in indexer database. Tokens aren’t “in” any specific UTXO—ownership is
account-based.</p>
<h3 data-number="3.4.2" id="asset-state-management"><span
class="header-section-number">3.4.2</span> 2.4.2 Asset State
Management</h3>
<p><strong>Indexer responsibilities</strong>: 1. Scan Bitcoin blocks for
stamp transactions 2. Decode stamp data (bare multisig or P2WSH) 3.
Parse asset operations (DEPLOY, MINT, TRANSFER) 4. Update account
balances per consensus rules 5. Serve API queries for balances, history,
metadata</p>
<p><strong>State schema</strong> (simplified):</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Account balances</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> balances (</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    address TEXT,</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    asset TEXT,</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    amount <span class="dt">NUMERIC</span>,</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">PRIMARY</span> <span class="kw">KEY</span> (address, asset)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Transfer history</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> transfers (</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    txid TEXT,</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    block_height <span class="dt">INTEGER</span>,</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    from_address TEXT,</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    to_address TEXT,</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    asset TEXT,</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    amount <span class="dt">NUMERIC</span>,</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">timestamp</span> <span class="dt">INTEGER</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- Asset metadata</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> assets (</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    asset_name TEXT <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    deploy_txid TEXT,</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    deploy_block <span class="dt">INTEGER</span>,</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>    total_supply <span class="dt">NUMERIC</span>,</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>    divisible <span class="dt">BOOLEAN</span>,</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">locked</span> <span class="dt">BOOLEAN</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>);</span></code></pre></div>
<p><strong>Consensus rules</strong> (SRC-20 example):</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> process_src20_transfer(tx, from_addr, to_addr, asset, amount):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Validation</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> balances[from_addr][asset] <span class="op">&lt;</span> amount:</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Insufficient balance</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># State update</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    balances[from_addr][asset] <span class="op">-=</span> amount</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    balances[to_addr][asset] <span class="op">+=</span> amount</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># History</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    transfers.append({</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;txid&#39;</span>: tx.txid,</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;from&#39;</span>: from_addr,</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;to&#39;</span>: to_addr,</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;asset&#39;</span>: asset,</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;amount&#39;</span>: amount,</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;block&#39;</span>: tx.block_height</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span></code></pre></div>
<p><strong>Reorganization handling</strong>:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> handle_reorg(old_chain_tip, new_chain_tip):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Rollback state to fork point</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    fork_height <span class="op">=</span> find_fork_point(old_chain_tip, new_chain_tip)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    rollback_to_height(fork_height)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Replay blocks from fork point to new tip</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> block <span class="kw">in</span> <span class="bu">range</span>(fork_height <span class="op">+</span> <span class="dv">1</span>, new_chain_tip.height <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        process_block(block)</span></code></pre></div>
<h3 data-number="3.4.3" id="transfer-mechanism"><span
class="header-section-number">3.4.3</span> 2.4.3 Transfer Mechanism</h3>
<p><strong>Transaction flow</strong>:</p>
<ol type="1">
<li><strong>User action</strong>: Send 100 KEVIN tokens to
recipient</li>
<li><strong>Transaction construction</strong>:
<ul>
<li><p>Create Bitcoin transaction from sender’s address</p></li>
<li><p>Embed SRC-20 TRANSFER operation in stamp encoding:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;p&quot;</span><span class="fu">:</span> <span class="st">&quot;src-20&quot;</span><span class="fu">,</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;op&quot;</span><span class="fu">:</span> <span class="st">&quot;transfer&quot;</span><span class="fu">,</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;tick&quot;</span><span class="fu">:</span> <span class="st">&quot;KEVIN&quot;</span><span class="fu">,</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;amt&quot;</span><span class="fu">:</span> <span class="st">&quot;100&quot;</span><span class="fu">,</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;to&quot;</span><span class="fu">:</span> <span class="st">&quot;bc1q...recipient&quot;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div></li>
<li><p>Broadcast to Bitcoin network</p></li>
</ul></li>
<li><strong>Block confirmation</strong>: Transaction included in Bitcoin
block</li>
<li><strong>Indexer processing</strong>:
<ul>
<li>Detects stamp transaction</li>
<li>Decodes TRANSFER operation</li>
<li>Validates sender has 100+ KEVIN balance</li>
<li>Updates balances: sender -100, recipient +100</li>
</ul></li>
<li><strong>User query</strong>: Recipient checks balance via indexer
API → sees 100 KEVIN</li>
</ol>
<p><strong>Key point</strong>: The Bitcoin transaction itself only
stores the TRANSFER instruction. Actual balance updates happen in
indexer state. Indexers independently compute same state by replaying
transactions.</p>
<p><strong>Consensus</strong>: Multiple indexers process same
blockchain, arrive at identical balances. If indexers disagree,
indicates implementation bug—consensus rules must be deterministic.</p>
<h2 data-number="3.5" id="layer-separation"><span
class="header-section-number">3.5</span> 2.5 Layer Separation</h2>
<h3 data-number="3.5.1" id="encoding-ownership"><span
class="header-section-number">3.5.1</span> 2.5.1 Encoding ≠
Ownership</h3>
<p><strong>Encoding layer</strong> (UTXO storage):</p>
<ul>
<li>Determines WHERE data is stored (which UTXOs)</li>
<li>Ensures permanence (consensus-critical storage)</li>
<li>Handles Bitcoin transaction construction</li>
<li><strong>Example</strong>: Bare multisig or P2WSH encoding</li>
</ul>
<p><strong>Asset tracking layer</strong> (account balances):</p>
<ul>
<li>Determines WHO owns WHAT (balances per address)</li>
<li>Manages transfer logic and validation</li>
<li>Maintains asset metadata and history</li>
<li><strong>Example</strong>: SRC-20 balance ledger</li>
</ul>
<p><strong>Independence</strong>: You can change encoding (bare multisig
→ P2WSH) without changing asset tracking. You can add new asset
standards (SRC-721, SRC-101) without changing encoding.</p>
<h3 data-number="3.5.2" id="standards-layer-flexibility"><span
class="header-section-number">3.5.2</span> 2.5.2 Standards Layer
Flexibility</h3>
<p><strong>Base stamps protocol</strong>:</p>
<ul>
<li>Defines encoding methods (bare multisig, P2WSH)</li>
<li>No inherent asset semantics</li>
<li>Just permanent data storage on Bitcoin</li>
</ul>
<p><strong>Standards define semantics</strong>:</p>
<ul>
<li><strong>SRC-20</strong>: Fungible tokens with DEPLOY/MINT/TRANSFER
operations</li>
<li><strong>SRC-721</strong>: Recursion standard for composable
stamps</li>
<li><strong>SRC-101</strong>: Decentralized naming system</li>
<li><strong>Future standards</strong>: Can add new semantics without
protocol changes</li>
</ul>
<p><strong>Example</strong>: A single stamp transaction can embed:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;stamp&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;image&quot;</span><span class="fu">:</span> <span class="st">&quot;base64_data&quot;</span><span class="fu">,</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;src20&quot;</span><span class="fu">:</span> <span class="fu">{</span><span class="dt">&quot;op&quot;</span><span class="fu">:</span> <span class="st">&quot;mint&quot;</span><span class="fu">,</span> <span class="dt">&quot;tick&quot;</span><span class="fu">:</span> <span class="st">&quot;TOKEN&quot;</span><span class="fu">,</span> <span class="dt">&quot;amt&quot;</span><span class="fu">:</span> <span class="st">&quot;1000&quot;</span><span class="fu">},</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;src721&quot;</span><span class="fu">:</span> <span class="fu">{</span><span class="dt">&quot;parent&quot;</span><span class="fu">:</span> <span class="dv">1234</span><span class="fu">,</span> <span class="dt">&quot;trait&quot;</span><span class="fu">:</span> <span class="st">&quot;golden&quot;</span><span class="fu">}</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">}</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p>Multiple standards operate on same underlying UTXO permanence.</p>
<h2 data-number="3.6" id="architecture-summary"><span
class="header-section-number">3.6</span> 2.6 Architecture Summary</h2>
<p><strong>Layered design</strong>: 1. <strong>Storage</strong>: Bitcoin
UTXO set (consensus-critical permanence) 2. <strong>Encoding</strong>:
Bare multisig or P2WSH (data → UTXOs) 3. <strong>Asset
tracking</strong>: Account-based ledger (Counterparty model) 4.
<strong>Standards</strong>: SRC-20/721/101 defining asset semantics 5.
<strong>Applications</strong>: Wallets, DEXs, explorers building on
indexer APIs</p>
<p><strong>Key innovations</strong>:</p>
<ul>
<li><strong>UTXO permanence</strong>: Leverage Bitcoin’s consensus
requirements for guaranteed storage</li>
<li><strong>Account simplicity</strong>: Counterparty-proven model
avoids UTXO tracking complexity</li>
<li><strong>Layer separation</strong>: Encoding independent from asset
logic; standards independent from protocol</li>
<li><strong>P2WSH optimization</strong>: OLGA reduces costs 30-95% while
maintaining permanence</li>
</ul>
<p><strong>Tradeoffs</strong>:</p>
<ul>
<li><strong>Higher fees</strong>: True cost of permanent Bitcoin storage
(vs prunable witness tricks)</li>
<li><strong>Indexer dependency</strong>: Need off-chain state
computation (vs pure Bitcoin validation)</li>
<li><strong>Larger UTXO set</strong>: Global node storage impact (vs
transient witness data)</li>
</ul>
<p><strong>Design philosophy</strong>: Embrace Bitcoin’s constraints,
pay true costs, achieve genuine permanence. No clever hacks—just aligned
incentives and honest economics.</p>
<hr />
<h1 data-number="4" id="token-standards"><span
class="header-section-number">4</span> 4. Token Standards</h1>
<p>The Bitcoin Stamps protocol supports three distinct token standards,
each optimized for specific use cases while maintaining the core
principle of UTXO-based immutability. All standards leverage Bitcoin’s
Proof-of-Work consensus mechanism, ensuring data integrity once
confirmed.</p>
<h2 data-number="4.1" id="src-20-fungible-token-standard"><span
class="header-section-number">4.1</span> 4.1 SRC-20: Fungible Token
Standard</h2>
<h3 data-number="4.1.1" id="overview"><span
class="header-section-number">4.1.1</span> Overview</h3>
<p>SRC-20 is an account-based fungible token protocol that enables fair,
accessible token creation with only standard Bitcoin miner fees.
Inspired by BRC-20 but designed with Stamps’ immutability guarantees,
SRC-20 operates directly on the Bitcoin blockchain without dependency on
Counterparty since block 796,000.</p>
<p><strong>Critical Design Note</strong>: SRC-20 is
<strong>account-based</strong>. Balances are tracked per address in
indexer state, NOT per UTXO. This distinguishes it from UTXO-based
protocols where tokens are locked in specific transaction outputs.</p>
<h3 data-number="4.1.2" id="first-deployment"><span
class="header-section-number">4.1.2</span> First Deployment</h3>
<p>The KEVIN token, deployed by Arwyn at block 788,041, represents the
genesis SRC-20 deployment.</p>
<h3 data-number="4.1.3" id="transaction-structure"><span
class="header-section-number">4.1.3</span> Transaction Structure</h3>
<p>SRC-20 transactions follow standardized JSON encoding embedded in
Bitcoin transaction outputs. Required fields include:</p>
<ul>
<li><code>p</code>: Protocol identifier (“src-20”)</li>
<li><code>op</code>: Operation type (deploy, mint, transfer)</li>
<li><code>tick</code>: Token ticker symbol</li>
<li>Additional operation-specific parameters</li>
</ul>
<h3 data-number="4.1.4" id="operations"><span
class="header-section-number">4.1.4</span> Operations</h3>
<p><strong>DEPLOY</strong>: Initializes a new token collection with
supply limits, per-mint caps, and optional pricing.</p>
<p><strong>MINT</strong>: Creates new token units within deployment
constraints. Minting continues until max supply is reached.</p>
<p><strong>TRANSFER</strong>: Moves tokens between addresses. The
indexer validates sender balance before updating account states.</p>
<h3 data-number="4.1.5" id="validation-and-indexing"><span
class="header-section-number">4.1.5</span> Validation and Indexing</h3>
<p>The indexer validates transactions through multi-step
verification:</p>
<ol type="1">
<li><strong>Length Verification</strong>: First two bytes represent
expected decoded data length in hex</li>
<li><strong>JSON Validation</strong>: Transaction must parse as valid
JSON with required fields</li>
<li><strong>Balance Check</strong>: For transfers, sender must hold
sufficient balance</li>
<li><strong>State Update</strong>: Successful transactions update the
account-based balance ledger</li>
</ol>
<p>Invalid transactions receive no stamp number and do not affect user
balances. The Rust-based parser provides 20-50x performance improvement
over pure Python implementations.</p>
<h3 data-number="4.1.6" id="economic-model"><span
class="header-section-number">4.1.6</span> Economic Model</h3>
<p>SRC-20 deployments incur only Bitcoin miner fees, eliminating token
burn requirements or auxiliary cryptocurrency costs. This “fair launch”
model ensures accessibility while maintaining immutability through UTXO
set storage.</p>
<h2 data-number="4.2" id="src-721-layered-nft-standard"><span
class="header-section-number">4.2</span> 4.2 SRC-721: Layered NFT
Standard</h2>
<h3 data-number="4.2.1" id="overview-1"><span
class="header-section-number">4.2.1</span> Overview</h3>
<p>SRC-721 addresses the economic challenge of high-resolution NFT
collections by introducing a layered composition architecture. Instead
of embedding complete images per mint, collections store reusable layer
components once, then reference them through lightweight JSON
manifests.</p>
<h3 data-number="4.2.2" id="architecture"><span
class="header-section-number">4.2.2</span> Architecture</h3>
<p><strong>Layer Storage</strong>: Collections deploy up to 10 layered
stamp images using standard Stamps protocol. Each layer is independently
stamped with full immutability guarantees.</p>
<p><strong>Composition Manifests</strong>: Users mint small JSON files
(~100-500 bytes) that reference pre-stamped layers, specifying:</p>
<ul>
<li>Layer stamp IDs</li>
<li>Stacking order (z-index)</li>
<li>Optional layer transformations</li>
<li>Metadata fields</li>
</ul>
<p><strong>Rendering</strong>: Client applications reconstruct final
artwork by retrieving and compositing referenced layers in specified
order.</p>
<h3 data-number="4.2.3" id="benefits"><span
class="header-section-number">4.2.3</span> Benefits</h3>
<ol type="1">
<li><strong>Cost Efficiency</strong>: 60-70% reduction in per-NFT
minting costs through layer reuse</li>
<li><strong>High Fidelity</strong>: Supports indexed color palettes and
high-resolution assets per layer</li>
<li><strong>Composability</strong>: Enables 10K PFP projects and
generative art collections</li>
<li><strong>Immutability</strong>: Both layers and manifests are
permanently stored in UTXO set</li>
</ol>
<h3 data-number="4.2.4" id="transaction-fields"><span
class="header-section-number">4.2.4</span> Transaction Fields</h3>
<p>Required fields for valid SRC-721 transactions:</p>
<ul>
<li><code>p</code>: “src-721”</li>
<li><code>op</code>: Operation type (deploy, mint)</li>
<li><code>layers</code>: Array of stamp IDs comprising the
composition</li>
<li><code>attributes</code>: Metadata describing trait composition</li>
</ul>
<h3 data-number="4.2.5" id="first-implementation"><span
class="header-section-number">4.2.5</span> First Implementation</h3>
<p>The AVIME collection by Derp Herpenstein, deployed at block 788041,
pioneered the SRC-721 standard.</p>
<h2 data-number="4.3" id="src-721r-recursive-rendering-standard"><span
class="header-section-number">4.3</span> 4.3 SRC-721r: Recursive
Rendering Standard</h2>
<h3 data-number="4.3.1" id="evolution-from-src-721"><span
class="header-section-number">4.3.1</span> Evolution from SRC-721</h3>
<p>SRC-721r extends the layered model by incorporating <strong>on-chain
JavaScript libraries</strong> for complex recursive rendering. This
enables animated, interactive, and algorithmically generated artwork
while maintaining complete on-chain data storage.</p>
<h3 data-number="4.3.2" id="technical-capabilities"><span
class="header-section-number">4.3.2</span> Technical Capabilities</h3>
<p><strong>JavaScript Runtime</strong>: Manifests can include or
reference stamped JavaScript libraries that execute client-side to
produce final artwork.</p>
<p><strong>Recursive Composition</strong>: Supports:</p>
<ul>
<li>Nested layer hierarchies</li>
<li>Algorithmic pattern generation</li>
<li>Animation sequences</li>
<li>Interactive elements responding to block data or timestamps</li>
</ul>
<p><strong>Library Reuse</strong>: Common rendering functions (e.g.,
noise generators, easing functions) are stamped once and referenced
across collections.</p>
<h3 data-number="4.3.3" id="use-cases"><span
class="header-section-number">4.3.3</span> Use Cases</h3>
<ul>
<li>Generative art projects with algorithmic variation</li>
<li>Animated collections with on-chain animation logic</li>
<li>Interactive NFTs responding to blockchain state</li>
<li>Complex visual effects requiring computational rendering</li>
</ul>
<h3 data-number="4.3.4" id="security-considerations"><span
class="header-section-number">4.3.4</span> Security Considerations</h3>
<p>All JavaScript executes client-side in sandboxed environments. The
protocol does not introduce execution risk to the Bitcoin network
itself, as rendering is strictly a presentation-layer concern.</p>
<h2 data-number="4.4" id="src-101-domain-registration-standard"><span
class="header-section-number">4.4</span> 4.4 SRC-101: Domain
Registration Standard</h2>
<h3 data-number="4.4.1" id="overview-2"><span
class="header-section-number">4.4.1</span> Overview</h3>
<p>SRC-101 provides a Bitcoin-native domain name service leveraging
Stamps’ immutability to solve UTXO-linked asset challenges. Jointly
developed by Bitname and Stamp teams, it enables permanent, address-tied
naming while supporting the entire Bitcoin ecosystem including Layer 2
solutions.</p>
<h3 data-number="4.4.2" id="core-design"><span
class="header-section-number">4.4.2</span> Core Design</h3>
<p>Domain names are stamped directly onto the Bitcoin blockchain as
permanent records tied to user addresses. This separates name ownership
from UTXO management, preventing accidental spending of domain-bearing
transaction outputs.</p>
<h3 data-number="4.4.3" id="operations-1"><span
class="header-section-number">4.4.3</span> Operations</h3>
<h4 data-number="4.4.3.1" id="deploy"><span
class="header-section-number">4.4.3.1</span> DEPLOY</h4>
<p>Creates a name service collection with deployment parameters:</p>
<ul>
<li><code>name</code>: Collection identifier</li>
<li><code>tick</code>: Token symbol (e.g., “BNS”)</li>
<li><code>owner</code>: Must match transaction signer</li>
<li><code>pri</code>: Price in satoshis per mint</li>
<li><code>max</code>: Supply limit (0 = unlimited)</li>
<li><code>lim</code>: Maximum 10 mint operations per transaction</li>
<li>Optional whitelist with discount rates</li>
</ul>
<h4 data-number="4.4.3.2" id="mint"><span
class="header-section-number">4.4.3.2</span> MINT</h4>
<p>Registers individual domain names:</p>
<ul>
<li>References deploy transaction hash</li>
<li><code>tokenid</code>: Name in hexadecimal format</li>
<li><code>dua</code>: Duration in years before expiration</li>
<li><code>toaddress</code>: Recipient (may differ from transaction
signer)</li>
</ul>
<h4 data-number="4.4.3.3" id="transfer"><span
class="header-section-number">4.4.3.3</span> TRANSFER</h4>
<p>Moves domain ownership between addresses:</p>
<ul>
<li>Transaction signer must be current owner</li>
<li><code>toaddress</code>: New recipient address</li>
<li>Supports all Bitcoin address types (Legacy, SegWit, Taproot)</li>
</ul>
<h4 data-number="4.4.3.4" id="setrecord"><span
class="header-section-number">4.4.3.4</span> SETRECORD</h4>
<p>Associates resolver data with domains:</p>
<ul>
<li>Supported record types: “address” (resolution target) and “txt”
(arbitrary metadata)</li>
<li>Signer must be service owner</li>
<li>Multiple records permitted; duplicate keys overwrite previous
values</li>
</ul>
<h4 data-number="4.4.3.5" id="renew"><span
class="header-section-number">4.4.3.5</span> RENEW</h4>
<p>Extends domain lease period:</p>
<ul>
<li>Requires owner authorization</li>
<li>Payment in satoshis per deployment pricing</li>
<li>Extends expiration by specified duration</li>
</ul>
<h4 data-number="4.4.3.6" id="transferownership"><span
class="header-section-number">4.4.3.6</span> TRANSFEROWNERSHIP</h4>
<p>Transfers administrative control of the name service:</p>
<ul>
<li>Service owner only</li>
<li>New owner assumes deployment-level permissions</li>
</ul>
<h3 data-number="4.4.4" id="address-interoperability"><span
class="header-section-number">4.4.4</span> Address Interoperability</h3>
<p>SRC-101 supports resolution and interconversion of all Bitcoin
address types, enabling seamless integration with:</p>
<ul>
<li>Mainnet (Legacy, P2SH, P2WPKH, P2WSH, Taproot)</li>
<li>Layer 2 protocols (Lightning Network, sidechains)</li>
<li>Bitcoin ecosystem extensions</li>
</ul>
<h3 data-number="4.4.5" id="economic-model-1"><span
class="header-section-number">4.4.5</span> Economic Model</h3>
<p>Deployers set per-mint pricing in satoshis, creating sustainable name
services without reliance on external fee structures. Renewal fees
provide ongoing revenue while ensuring active namespace use.</p>
<h2 data-number="4.5" id="cross-protocol-guarantees"><span
class="header-section-number">4.5</span> 4.5 Cross-Protocol
Guarantees</h2>
<p>All token standards share fundamental properties:</p>
<ol type="1">
<li><strong>Immutability</strong>: Data stored in UTXO set cannot be
pruned or modified</li>
<li><strong>Consensus Security</strong>: Protected by Bitcoin’s
Proof-of-Work</li>
<li><strong>Indexer Validation</strong>: Multiple independent indexer
implementations can verify state</li>
<li><strong>No Burn Requirements</strong>: Only Bitcoin miner fees
required</li>
<li><strong>Open Source</strong>: Reference indexer and validation logic
publicly available</li>
</ol>
<p>These guarantees distinguish Stamps-based protocols from witness-data
alternatives that compromise on permanence or introduce auxiliary
dependencies.</p>
<h1 data-number="5" id="economic-model-2"><span
class="header-section-number">5</span> 5. Economic Model</h1>
<p>The Bitcoin Stamps protocol’s economic model is fundamentally shaped
by its design choice to store data in the UTXO set rather than witness
data. This section analyzes the permanence guarantees, cost structures,
and economic tradeoffs inherent to this architecture.</p>
<h2 data-number="5.1" id="utxo-set-permanence-guarantees"><span
class="header-section-number">5.1</span> 5.1 UTXO Set Permanence
Guarantees</h2>
<h3 data-number="5.1.1" id="architectural-foundation"><span
class="header-section-number">5.1.1</span> Architectural Foundation</h3>
<p>Bitcoin Stamps are stored directly in Bitcoin’s Unspent Transaction
Output (UTXO) set, which full nodes maintain in memory or indexed
storage for efficient transaction validation. This contrasts with
witness-data protocols (e.g., Ordinals) that leverage SegWit’s
discounted witness field for data inscription.</p>
<h3 data-number="5.1.2" id="permanence-mechanism"><span
class="header-section-number">5.1.2</span> Permanence Mechanism</h3>
<p><strong>Unprunable by Design</strong>: UTXO set entries cannot be
pruned from full nodes without breaking consensus rules. While nodes can
prune historical block data and witness information after verification,
they must retain all unspent outputs to validate new transactions.</p>
<p><strong>Stamp UTXOs</strong>: Once created, Stamp-bearing UTXOs are
expected to remain unspent indefinitely, ensuring: 1. Data persists in
the globally replicated UTXO set 2. No dependency on archival node
policies 3. Immunity to pruning configurations</p>
<p><strong>Counterparty Integration</strong>: Classic Stamps leverage
Counterparty’s bare multisig (P2MS) outputs, which chunk image data
across multiple outputs. By avoiding OP_RETURN (limited to 80 bytes and
prunable), Stamps achieve true immutability.</p>
<h3 data-number="5.1.3" id="economic-implications-of-permanence"><span
class="header-section-number">5.1.3</span> Economic Implications of
Permanence</h3>
<p><strong>UTXO Set Bloat</strong>: Every Stamp contributes to permanent
UTXO set growth, imposing ongoing storage costs on all full nodes. As of
2026, the UTXO set exceeds 10GB, with protocols like Stamps representing
a measurable fraction.</p>
<p><strong>Node Operation Costs</strong>: Validators bear the cost of
storing Stamp UTXOs perpetually, creating a commons dilemma where
minters externalize storage costs to the network.</p>
<p><strong>Economic Finality</strong>: Permanence ensures that Stamp
data survives even catastrophic scenarios (e.g., protocol deprecation,
indexer abandonment). The data exists independently of any external
service.</p>
<h2 data-number="5.2" id="storage-format-evolution"><span
class="header-section-number">5.2</span> 5.2 Storage Format
Evolution</h2>
<h3 data-number="5.2.1" id="bare-multisig-op_multisig"><span
class="header-section-number">5.2.1</span> Bare Multisig
(OP_MULTISIG)</h3>
<p><strong>Original Format</strong>: Early Stamps used Counterparty’s
bare multisig encoding:</p>
<ul>
<li>Base64-encode image binary</li>
<li>Split encoded data into 33-byte chunks</li>
<li>Embed chunks as fake public keys in multisig outputs (e.g., 1-of-3,
2-of-3)</li>
</ul>
<p><strong>Size Limits</strong>: Maximum 7KB per Stamp due to standard
transaction size constraints.</p>
<p><strong>Weight Calculation</strong>: Multisig data is stored in the
base transaction block, counting as 4 weight units per byte under
SegWit’s accounting.</p>
<h3 data-number="5.2.2" id="p2wsh-migration"><span
class="header-section-number">5.2.2</span> P2WSH Migration</h3>
<p><strong>Efficiency Gains</strong>: Pay-to-Witness-Script-Hash (P2WSH)
outputs store data in the witness field, which receives a 75% discount
under SegWit rules:</p>
<ul>
<li>Base block data: 4 weight units per byte</li>
<li>Witness data: 1 weight unit per byte</li>
</ul>
<p><strong>Cost Reduction</strong>: P2WSH-based Stamps pay ~25% of bare
multisig fees for equivalent data size.</p>
<p><strong>Pruning Concern</strong>: Witness data is technically
prunable by nodes that don’t serve historical blocks. However, archival
nodes and blockchain explorers retain witness data, ensuring practical
permanence.</p>
<p><strong>Stamps P2WSH Variant</strong>: Stamps protocol adopted P2WSH
for certain formats while maintaining UTXO set references, balancing
cost efficiency with permanence goals.</p>
<h3 data-number="5.2.3" id="olga-encoding"><span
class="header-section-number">5.2.3</span> OLGA Encoding</h3>
<p><strong>Breakthrough Optimization</strong>: P2WSH encoding was
enabled at block 833,000 (<code>CP_P2WSH_FEAT_BLOCK_START</code>), with
the first SRC-20 OLGA transaction at block 865,000
(<code>BTC_SRC20_OLGA_BLOCK</code>). OLGA (Octet Linked Graphical
Artifacts) eliminates Base64 encoding:</p>
<p><strong>Technical Innovation</strong>:</p>
<ul>
<li>Stores raw binary data directly in transaction outputs</li>
<li>Removes 33% overhead from Base64 conversion</li>
<li>Achieves 50% transaction size reduction vs. OP_MULTISIG</li>
<li>Reduces minting costs by 60-70%</li>
</ul>
<p><strong>Size Expansion</strong>: Maximum file size increased to 64KB,
enabling higher-fidelity artwork and larger datasets.</p>
<p><strong>Adoption</strong>: OLGA became the standard for new Stamps
due to dramatic cost savings without compromising immutability.</p>
<h2 data-number="5.3" id="miner-fee-economics"><span
class="header-section-number">5.3</span> 5.3 Miner Fee Economics</h2>
<h3 data-number="5.3.1" id="fee-market-competition"><span
class="header-section-number">5.3.1</span> Fee Market Competition</h3>
<p><strong>Base Layer Fees</strong>: Stamp minters compete in Bitcoin’s
fee market alongside financial transactions. During congestion (e.g.,
Ordinals inscription waves, halving periods), Stamp costs scale
proportionally.</p>
<p><strong>Fee Rate Dynamics</strong>:</p>
<ul>
<li>Low congestion: 1-5 sat/vByte (Stamps cost $0.50-$5 per KB)</li>
<li>Medium congestion: 20-50 sat/vByte (Stamps cost $10-$30 per KB)</li>
<li>High congestion: 100-500 sat/vByte (Stamps cost $60-$300 per
KB)</li>
</ul>
<p><strong>Batching Economies</strong>: Minting multiple Stamps in a
single transaction amortizes overhead:</p>
<ul>
<li>Single Stamp: ~300 bytes overhead + data</li>
<li>10 Stamps: ~300 bytes overhead + (10 × data), reducing per-Stamp
cost</li>
</ul>
<h3 data-number="5.3.2" id="cost-structure-analysis"><span
class="header-section-number">5.3.2</span> Cost Structure Analysis</h3>
<p><strong>Per-Stamp Breakdown</strong> (OLGA format, 5KB image, 20
sat/vByte):</p>
<table>
<thead>
<tr class="header">
<th>Component</th>
<th>Size</th>
<th>Cost</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Transaction overhead</td>
<td>150 bytes</td>
<td>3,000 sats</td>
</tr>
<tr class="even">
<td>OLGA data (5KB)</td>
<td>5,000 bytes</td>
<td>100,000 sats</td>
</tr>
<tr class="odd">
<td>Output creation</td>
<td>50 bytes</td>
<td>1,000 sats</td>
</tr>
<tr class="even">
<td><strong>Total</strong></td>
<td><strong>5,200 bytes</strong></td>
<td><strong>~104,000 sats (~$62 @ $60K BTC)</strong></td>
</tr>
</tbody>
</table>
<p><strong>Comparative Costs</strong>:</p>
<ul>
<li>Ordinals inscription (5KB): ~26,000 sats (~$16) — 75% cheaper due to
witness discount</li>
<li>Classic Stamp (Base64): ~180,000 sats (~$108) — 73% more expensive
due to encoding overhead</li>
<li>OLGA Stamp: ~104,000 sats (~$62) — balanced cost-permanence
tradeoff</li>
</ul>
<h3 data-number="5.3.3" id="miner-revenue-impact"><span
class="header-section-number">5.3.3</span> Miner Revenue Impact</h3>
<p><strong>Protocol Contribution</strong>: During 2023-2024 inscription
waves, data-heavy protocols contributed 5-15% of miner fee revenue, with
Stamps representing a smaller but consistent fraction.</p>
<p><strong>Incentive Alignment</strong>: Stamp minters directly
compensate miners for permanent block space allocation, aligning
economic incentives without protocol subsidies.</p>
<h2 data-number="5.4" id="storage-cost-comparison"><span
class="header-section-number">5.4</span> 5.4 Storage Cost
Comparison</h2>
<h3 data-number="5.4.1" id="bitcoin-stamps-vs.-ordinals"><span
class="header-section-number">5.4.1</span> Bitcoin Stamps
vs. Ordinals</h3>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 30%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="header">
<th>Attribute</th>
<th>Bitcoin Stamps</th>
<th>Ordinals (Inscriptions)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Storage Location</strong></td>
<td>UTXO set (base block data or P2WSH witness)</td>
<td>Witness data (SegWit)</td>
</tr>
<tr class="even">
<td><strong>Prunability</strong></td>
<td>Unprunable (UTXO set)</td>
<td>Technically prunable (witness)</td>
</tr>
<tr class="odd">
<td><strong>Cost Multiplier</strong></td>
<td>4x (OP_MULTISIG) to 1x (P2WSH OLGA)</td>
<td>1x (witness discount)</td>
</tr>
<tr class="even">
<td><strong>Size Limit</strong></td>
<td>64KB (OLGA), 7KB (legacy)</td>
<td>~400KB (block size constraints)</td>
</tr>
<tr class="odd">
<td><strong>Node Impact</strong></td>
<td>Perpetual UTXO set growth</td>
<td>Witness data pruning reduces impact</td>
</tr>
<tr class="even">
<td><strong>Economic Model</strong></td>
<td>Minter pays permanent externality</td>
<td>Minter pays discounted temporary cost</td>
</tr>
</tbody>
</table>
<h3 data-number="5.4.2" id="utxo-set-growth-implications"><span
class="header-section-number">5.4.2</span> UTXO Set Growth
Implications</h3>
<p><strong>Long-Term Costs</strong>: As of 2026, storing 1GB of UTXO
data costs validators:</p>
<ul>
<li>SSD storage: ~$0.10/GB/year</li>
<li>RAM caching (performance nodes): ~$5/GB/year</li>
</ul>
<p><strong>Scaling Concerns</strong>: If Stamps adoption scales to 100GB
UTXO footprint, validators face:</p>
<ul>
<li>$10/year storage costs (SSD)</li>
<li>$500/year RAM costs (high-performance nodes)</li>
</ul>
<p>These costs are externalized to the network, raising debate over
sustainable protocol economics.</p>
<h3 data-number="5.4.3" id="alternative-protocols"><span
class="header-section-number">5.4.3</span> Alternative Protocols</h3>
<p><strong>IPFS + Bitcoin Anchoring</strong>: Store data off-chain
(IPFS), anchor hashes on Bitcoin:</p>
<ul>
<li>Cost: ~200 bytes per anchor (~$2 at 20 sat/vByte)</li>
<li>Tradeoff: Requires IPFS network availability; not truly
immutable</li>
</ul>
<p><strong>Arweave + Bitcoin Verification</strong>: Permanent storage
layer with Bitcoin proof references:</p>
<ul>
<li>Cost: ~$5-$10 per MB on Arweave</li>
<li>Tradeoff: Dependency on Arweave network; cross-chain trust
assumptions</li>
</ul>
<p><strong>Stamps Advantage</strong>: True Bitcoin-native permanence
without external dependencies, at the cost of higher fees and UTXO set
impact.</p>
<h2 data-number="5.5" id="economic-sustainability"><span
class="header-section-number">5.5</span> 5.5 Economic
Sustainability</h2>
<h3 data-number="5.5.1" id="protocol-fee-structure"><span
class="header-section-number">5.5.1</span> Protocol Fee Structure</h3>
<p><strong>No Native Fees</strong>: Stamps protocol itself collects no
fees. All costs are miner fees paid to Bitcoin validators.</p>
<p><strong>Token Economics</strong> (SRC-20/721/101):</p>
<ul>
<li><strong>Deploy Fees</strong>: Set by deployer; collected in satoshis
by minting smart contracts or indexer-enforced logic</li>
<li><strong>Royalties</strong>: Not enforced at protocol level;
marketplace-dependent</li>
<li><strong>Renewal Fees</strong> (SRC-101): Deployer-set pricing for
domain lease extensions</li>
</ul>
<h3 data-number="5.5.2" id="miner-incentive-alignment"><span
class="header-section-number">5.5.2</span> Miner Incentive
Alignment</h3>
<p><strong>Short-Term</strong>: Stamps generate direct fee revenue for
miners, incentivizing block inclusion during low-congestion periods.</p>
<p><strong>Long-Term</strong>: UTXO set growth imposes costs on future
miners/validators. If externalized costs exceed fee revenue, validators
may advocate for protocol-level restrictions.</p>
<h3 data-number="5.5.3" id="market-driven-equilibrium"><span
class="header-section-number">5.5.3</span> Market-Driven
Equilibrium</h3>
<p><strong>Fee Market Regulation</strong>: High congestion naturally
limits Stamp creation as costs rise, creating self-regulating supply
dynamics.</p>
<p><strong>Quality vs. Quantity</strong>: Expensive minting favors
high-value assets (rare art, critical data) over spam, improving
signal-to-noise ratio.</p>
<p><strong>Indexer Sustainability</strong>: Open-source indexer model
ensures community-driven validation without centralized service
dependencies. Multiple independent indexers can verify state, preventing
single points of failure.</p>
<h2 data-number="5.6" id="economic-tradeoffs-summary"><span
class="header-section-number">5.6</span> 5.6 Economic Tradeoffs
Summary</h2>
<h3 data-number="5.6.1" id="advantages"><span
class="header-section-number">5.6.1</span> Advantages</h3>
<ol type="1">
<li><strong>True Immutability</strong>: UTXO-based storage guarantees
permanence without reliance on archival nodes</li>
<li><strong>Censorship Resistance</strong>: Data survives even if
protocol indexers cease operation</li>
<li><strong>Bitcoin-Native Security</strong>: Inherits full
Proof-of-Work consensus guarantees</li>
<li><strong>No Auxiliary Dependencies</strong>: Only Bitcoin miner fees
required; no token burns or external fees</li>
</ol>
<h3 data-number="5.6.2" id="disadvantages"><span
class="header-section-number">5.6.2</span> Disadvantages</h3>
<ol type="1">
<li><strong>High Costs</strong>: 1-4x more expensive than witness-based
alternatives</li>
<li><strong>UTXO Set Externality</strong>: Imposes permanent storage
costs on all validators</li>
<li><strong>Scaling Constraints</strong>: Limited to ~64KB per asset
(OLGA), vs. 400KB for Ordinals</li>
<li><strong>Fee Market Competition</strong>: Vulnerable to
congestion-driven cost spikes</li>
</ol>
<h3 data-number="5.6.3" id="strategic-positioning"><span
class="header-section-number">5.6.3</span> Strategic Positioning</h3>
<p>Bitcoin Stamps occupies the “maximum permanence” niche within
Bitcoin’s data inscription ecosystem. Users willing to pay premium costs
for uncompromising immutability choose Stamps over cheaper, less
permanent alternatives. This positions the protocol as a premium
store-of-value layer for digital artifacts requiring absolute permanence
guarantees.</p>
<p><strong>References</strong>:</p>
<ul>
<li><a href="https://research.mempool.space/utxo-set-report/">Bitcoin
UTXO Set Research</a></li>
<li><a
href="https://bitcoinmagazine.com/technical/the-witness-discount-why-some-bytes-are-cheaper-than-others">SegWit
Witness Discount Analysis</a></li>
<li><a
href="https://coinpedia.org/guest-post/bitcoin-stamps-vs-ordinals-deep-dive-into-future-of-on-chain-permanence/">Bitcoin
Stamps vs Ordinals Permanence Analysis</a></li>
<li><a
href="https://blog.lopp.net/economically-unspendable-bitcoin-utxos/">Economically
Unspendable Bitcoin UTXOs</a></li>
<li><a
href="https://bitcoincore.org/en/2016/10/28/segwit-costs/">Bitcoin Core
SegWit Costs and Risks</a></li>
<li><a href="https://stampchain.io/faq">Bitcoin Stamps FAQ</a></li>
</ul>
<h1 data-number="6" id="stamps-improvement-proposals-sips"><span
class="header-section-number">6</span> 6. Stamps Improvement Proposals
(SIPs)</h1>
<h2 data-number="6.1" id="sip-governance-framework"><span
class="header-section-number">6.1</span> 6.1 SIP Governance
Framework</h2>
<p>Bitcoin Stamps protocol evolves through community-driven Stamps
Improvement Proposals (SIPs). This governance model balances protocol
stability with extensibility, enabling vetted enhancements while
preserving core immutability guarantees.</p>
<h3 data-number="6.1.1" id="sip-lifecycle"><span
class="header-section-number">6.1.1</span> 6.1.1 SIP Lifecycle</h3>
<p><strong>Draft</strong>: Proposal submitted as GitHub Issue with
specification outline. Author presents motivation, technical design, and
backward compatibility analysis.</p>
<p><strong>Review</strong>: Community discussion period (minimum 14
days). Technical reviewers evaluate:</p>
<ul>
<li>Specification clarity and completeness</li>
<li>Implementation feasibility</li>
<li>Security implications</li>
<li>Impact on existing stamps and indexers</li>
<li>Alignment with protocol philosophy</li>
</ul>
<p><strong>Accepted</strong>: Proposal achieves rough consensus among
core developers and major indexer implementations. Specification
finalized with version number (SIP-XXXX).</p>
<p><strong>Activated</strong>: Implementation deployed with activation
block height set 4+ weeks in future. Advance notice ensures all
indexers, wallets, and services update before consensus rule changes
take effect.</p>
<p><strong>Final</strong>: Activation block height reached. New rules
enforced by all compliant indexers. Proposal becomes immutable
specification.</p>
<p><strong>Superseded</strong>: Later SIP replaces or invalidates
earlier proposal. Original SIP remains in historical record but no
longer active.</p>
<h3 data-number="6.1.2" id="activation-lead-time"><span
class="header-section-number">6.1.2</span> 6.1.2 Activation Lead
Time</h3>
<p><strong>Critical Safety Mechanism</strong>: All consensus-changing
SIPs must specify activation block height at least <strong>4 weeks
(approximately 4,032 blocks)</strong> after acceptance.</p>
<p><strong>Rationale</strong>:</p>
<ul>
<li>Indexer operators need time to upgrade software</li>
<li>Wallet developers must integrate new transaction formats</li>
<li>Service providers require testing and deployment cycles</li>
<li>Community members must understand changes before activation</li>
</ul>
<p><strong>Historical Precedent</strong>: Block 796,000 (SRC-20
Counterparty cutoff) and block 865,000 (OLGA activation) both provided
multi-week advance notice, ensuring smooth transitions without network
disruption.</p>
<h3 data-number="6.1.3" id="consensus-requirements"><span
class="header-section-number">6.1.3</span> 6.1.3 Consensus
Requirements</h3>
<p><strong>Indexer Consensus</strong>: Bitcoin Stamps has no on-chain
consensus mechanism. Protocol rules are enforced by indexer
implementations. SIP activation requires:</p>
<ul>
<li><strong>Reference Indexer</strong>: stampchain.io (official
implementation) must deploy support</li>
<li><strong>Secondary Indexers</strong>: At least 2 independent
implementations demonstrate compatibility</li>
<li><strong>Community Signaling</strong>: No significant objections from
major stakeholders</li>
</ul>
<p><strong>Backward Compatibility</strong>: SIPs should maintain
compatibility with existing stamps whenever possible. Breaking changes
require strong justification and comprehensive migration path.</p>
<h3 data-number="6.1.4" id="github-issue-tracking"><span
class="header-section-number">6.1.4</span> 6.1.4 GitHub Issue
Tracking</h3>
<p>All SIPs are tracked as GitHub Issues in the Bitcoin Stamps
repository:</p>
<ul>
<li><strong>Repository</strong>:
https://github.com/stampchain-io/btc_stamps</li>
<li><strong>Issue Labels</strong>: <code>SIP</code>,
<code>enhancement</code>, <code>consensus-change</code></li>
<li><strong>Discussion Forum</strong>: GitHub Discussions for
preliminary ideas before formal SIP submission</li>
</ul>
<h2 data-number="6.2" id="active-sips"><span
class="header-section-number">6.2</span> 6.2 Active SIPs</h2>
<h3 data-number="6.2.1"
id="sip-0001-src-20-htlc-hash-time-locked-contracts"><span
class="header-section-number">6.2.1</span> 6.2.1 SIP-0001: SRC-20 HTLC
(Hash Time-Locked Contracts)</h3>
<p><strong>GitHub Issue</strong>: <a
href="https://github.com/stampchain-io/btc_stamps/issues/685">#685</a></p>
<p><strong>Status</strong>: Draft (as of 2026-02)</p>
<p><strong>Motivation</strong>: Enable trustless atomic swaps and escrow
services for SRC-20 tokens through hash time-locked contracts. Supports
cross-asset exchanges and conditional transfers without requiring
external oracles or modifying Bitcoin consensus.</p>
<p><strong>Technical Design</strong>:</p>
<p>SIP-0001 introduces three new SRC-20 operations:</p>
<p><strong>1. <code>conditional_transfer</code> — Create HTLC with
hashlock and/or timelock</strong>:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;p&quot;</span><span class="fu">:</span> <span class="st">&quot;src-20&quot;</span><span class="fu">,</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;op&quot;</span><span class="fu">:</span> <span class="st">&quot;conditional_transfer&quot;</span><span class="fu">,</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;tick&quot;</span><span class="fu">:</span> <span class="st">&quot;KEVIN&quot;</span><span class="fu">,</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;amt&quot;</span><span class="fu">:</span> <span class="st">&quot;1000&quot;</span><span class="fu">,</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;to&quot;</span><span class="fu">:</span> <span class="st">&quot;bc1q...recipient&quot;</span><span class="fu">,</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;hashlock&quot;</span><span class="fu">:</span> <span class="st">&quot;a4b9c8d7e6f5...sha256hash&quot;</span><span class="fu">,</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;timelock&quot;</span><span class="fu">:</span> <span class="dv">900000</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<ul>
<li><strong>hashlock</strong> (optional): SHA-256 hash — recipient must
reveal preimage to claim</li>
<li><strong>timelock</strong> (optional): Block height — sender can
refund after this block if unclaimed</li>
<li>At least one of hashlock/timelock required</li>
<li>Tokens deducted from sender immediately, held in indexer escrow
state</li>
</ul>
<p><strong>2. <code>claim</code> — Recipient claims tokens with
preimage</strong>:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;p&quot;</span><span class="fu">:</span> <span class="st">&quot;src-20&quot;</span><span class="fu">,</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;op&quot;</span><span class="fu">:</span> <span class="st">&quot;claim&quot;</span><span class="fu">,</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;tick&quot;</span><span class="fu">:</span> <span class="st">&quot;KEVIN&quot;</span><span class="fu">,</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;transfer_tx&quot;</span><span class="fu">:</span> <span class="st">&quot;abc123...original_txid&quot;</span><span class="fu">,</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;preimage&quot;</span><span class="fu">:</span> <span class="st">&quot;secret_value&quot;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<ul>
<li>Indexer verifies <code>SHA-256(preimage)</code> matches
hashlock</li>
<li>Must be before timelock block height (if timelock set)</li>
<li>Tokens credited to recipient</li>
</ul>
<p><strong>3. <code>refund</code> — Sender reclaims tokens after
timelock expires</strong>:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;p&quot;</span><span class="fu">:</span> <span class="st">&quot;src-20&quot;</span><span class="fu">,</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;op&quot;</span><span class="fu">:</span> <span class="st">&quot;refund&quot;</span><span class="fu">,</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;tick&quot;</span><span class="fu">:</span> <span class="st">&quot;KEVIN&quot;</span><span class="fu">,</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;transfer_tx&quot;</span><span class="fu">:</span> <span class="st">&quot;abc123...original_txid&quot;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<ul>
<li>Only valid after timelock block height reached</li>
<li>Tokens returned to original sender</li>
</ul>
<p><strong>Use Cases</strong>:</p>
<ul>
<li><strong>Atomic swaps</strong>: Cross-asset exchange (e.g., KEVIN ↔︎
STAMP) with cryptographic settlement</li>
<li><strong>Escrow services</strong>: Time-locked deposits with refund
guarantees</li>
<li><strong>Trustless bridge deposits</strong>: Lock tokens with
hashlock, mint on L2 with preimage reveal (see SIP-0003)</li>
<li><strong>Time-locked vesting</strong>: Gradual token unlock over
time</li>
</ul>
<p><strong>Challenges</strong>:</p>
<ul>
<li><strong>Liveness requirement</strong>: Both parties must be online
during swap window</li>
<li><strong>Timelock griefing</strong>: Malicious actors can lock
counterparty funds then abandon swap</li>
<li><strong>Multi-step process</strong>: Atomic swap requires 4
transactions (2 conditional_transfer + 2 claim)</li>
<li><strong>Indexer validation complexity</strong>: Requires SHA-256
verification and timelock enforcement</li>
</ul>
<p><strong>Activation Timeline</strong>: TBD pending community review
and implementation testing.</p>
<h3 data-number="6.2.2" id="sip-0003-cross-chain-bridges"><span
class="header-section-number">6.2.2</span> 6.2.2 SIP-0003: Cross-Chain
Bridges</h3>
<p><strong>GitHub Issue</strong>: <a
href="https://github.com/stampchain-io/btc_stamps/issues/485">#485</a></p>
<p><strong>Status</strong>: Draft (as of 2026-02)</p>
<p><strong>Motivation</strong>: Enable SRC-20 token movement between
Bitcoin mainnet and Layer 2 protocols (Lightning Network, sidechains,
rollups) while maintaining UTXO-based permanence guarantees for bridged
asset records.</p>
<p><strong>Architecture</strong>:</p>
<pre><code>Bitcoin L1 (Stamps)  ←→  Bridge Contract  ←→  L2 Protocol
     |                        |                      |
  Lock asset          Mint wrapped token       Fast transfers
  (UTXO proof)        (bridge attestation)     (off-chain)</code></pre>
<p><strong>Bridge Operations</strong>:</p>
<ol type="1">
<li><strong>Lock</strong> (L1 → L2):
<ul>
<li>User sends SRC-20 transfer to bridge address</li>
<li>Bridge operators verify transaction and UTXO proof</li>
<li>L2 mints equivalent wrapped token to user address</li>
</ul></li>
<li><strong>Unlock</strong> (L2 → L1):
<ul>
<li>User burns wrapped token on L2</li>
<li>Bridge operators create SRC-20 transfer from bridge address to
user</li>
<li>Bitcoin transaction permanently records bridge event</li>
</ul></li>
</ol>
<p><strong>Security Model</strong>:</p>
<ul>
<li><strong>Federated multisig</strong>: M-of-N bridge operators hold
Bitcoin keys</li>
<li><strong>Fraud proofs</strong>: Users can challenge invalid bridge
operations</li>
<li><strong>Timelock withdrawals</strong>: Delay allows dispute
resolution</li>
</ul>
<p><strong>Implementation Requirements</strong>:</p>
<ul>
<li>Bridge indexer module for cross-chain state verification</li>
<li>Oracle network for L2 state attestation</li>
<li>Emergency pause mechanism for security incidents</li>
</ul>
<p><strong>Activation Timeline</strong>: Pending security audit and
testnet deployment (target Q3 2026).</p>
<h3 data-number="6.2.3" id="sip-0004-privacy-enhancements"><span
class="header-section-number">6.2.3</span> 6.2.3 SIP-0004: Privacy
Enhancements</h3>
<p><strong>GitHub Issue</strong>: <a
href="https://github.com/stampchain-io/btc_stamps/issues/687">#687</a></p>
<p><strong>Status</strong>: Draft (as of 2026-02)</p>
<p><strong>Motivation</strong>: Improve SRC-20 transfer privacy through
cryptographic commitments while maintaining indexer verifiability.
Address concern that account-based model exposes address balances
publicly.</p>
<p><strong>Privacy Techniques</strong>:</p>
<p><strong>1. Confidential Amounts</strong>:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Pedersen commitments hide transfer amounts</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>commitment <span class="op">=</span> amount <span class="op">*</span> G <span class="op">+</span> blinding_factor <span class="op">*</span> H</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Indexer verifies: commitment_in == commitment_out (balance preserved)</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Amount remains hidden from public queries</span></span></code></pre></div>
<p><strong>2. Stealth Addresses</strong>:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># One-time address per transfer</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>stealth_addr <span class="op">=</span> <span class="bu">hash</span>(sender_secret <span class="op">+</span> recipient_pubkey)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Only recipient can detect and claim transfer</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Breaks on-chain address linkage</span></span></code></pre></div>
<p><strong>3. Range Proofs</strong>:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Prove amount is positive without revealing value</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>prove(<span class="dv">0</span> <span class="op">&lt;</span> amount <span class="op">&lt;</span> max_supply)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Prevents negative balance attacks</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Maintains confidentiality</span></span></code></pre></div>
<p><strong>Tradeoffs</strong>:</p>
<ul>
<li><strong>Proof size</strong>: Range proofs add 1-2KB per transfer
(higher fees)</li>
<li><strong>Validation cost</strong>: Indexers must verify cryptographic
proofs (slower sync)</li>
<li><strong>Regulatory risk</strong>: Privacy features may face
jurisdictional challenges</li>
<li><strong>Complexity</strong>: Wallet implementations require
cryptographic libraries</li>
</ul>
<p><strong>Phased Rollout</strong>:</p>
<ul>
<li><strong>Phase 1</strong>: Optional confidential amounts for willing
users</li>
<li><strong>Phase 2</strong>: Stealth address support in major
wallets</li>
<li><strong>Phase 3</strong>: Full privacy by default with opt-out
mechanism</li>
</ul>
<p><strong>Activation Timeline</strong>: Specification under development
(target 2027).</p>
<h3 data-number="6.2.4"
id="sip-0005-binary-transfer-format-for-src-20"><span
class="header-section-number">6.2.4</span> 6.2.4 SIP-0005: Binary
Transfer Format for SRC-20</h3>
<p><strong>GitHub Issue</strong>: <a
href="https://github.com/stampchain-io/btc_stamps/issues/688">#688</a></p>
<p><strong>Status</strong>: Draft (as of 2026-02)</p>
<p><strong>Motivation</strong>: Replace JSON-encoded SRC-20 transactions
with compact binary format. Reduce transaction size by approximately
63%, lowering minting costs and increasing throughput.</p>
<p><strong>Format Specification</strong>:</p>
<pre><code>Binary SRC-20 Transfer Format (44 bytes total):
&lt;prefix:6&gt;&lt;version:1&gt;&lt;op:1&gt;&lt;tick:20&gt;&lt;amount:8&gt;&lt;decimals:8&gt; = 44 bytes raw</code></pre>
<p><strong>Field Breakdown</strong>:</p>
<ul>
<li><strong>prefix</strong> (6 bytes): <code>stamp:</code> — indexer
detection marker (ASCII: <code>73 74 61 6D 70 3A</code>)</li>
<li><strong>version</strong> (1 byte): <code>0x01</code> for format
version 1</li>
<li><strong>op</strong> (1 byte): Operation code
<ul>
<li><code>0x01</code>: DEPLOY</li>
<li><code>0x02</code>: MINT</li>
<li><code>0x03</code>: TRANSFER</li>
</ul></li>
<li><strong>tick</strong> (20 bytes): UTF-8 ticker padded with null
bytes
<ul>
<li>Example: “KEVIN” → <code>4B 45 56 49 4E</code> + 15 null bytes
(<code>0x00</code>)</li>
</ul></li>
<li><strong>amount</strong> (8 bytes): uint64 big-endian raw amount (not
decimal-adjusted)</li>
<li><strong>decimals</strong> (8 bytes): uint64 big-endian decimal
precision</li>
</ul>
<p><strong>Detection Logic</strong>:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> data[:<span class="dv">6</span>] <span class="op">==</span> <span class="st">b&#39;stamp:&#39;</span> <span class="kw">and</span> data[<span class="dv">6</span>] <span class="op">==</span> <span class="bn">0x01</span>:</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Binary format</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    parse_binary(data)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># JSON format (backward compatible)</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    parse_json(data)</span></code></pre></div>
<p><strong>Benefits</strong>:</p>
<ul>
<li><strong>~63% size reduction</strong>: 44 bytes binary vs ~120 bytes
JSON</li>
<li><strong>Faster indexer parsing</strong>: Binary deserialization vs
JSON parsing</li>
<li><strong>Lower transaction fees</strong>: Smaller data size reduces
on-chain costs</li>
<li><strong>Increased data density</strong>: More stamps per block</li>
</ul>
<p><strong>Migration Strategy</strong>:</p>
<ul>
<li>Binary format optional after activation</li>
<li>JSON format remains valid indefinitely (backward compatibility)</li>
<li>Indexers must support both formats simultaneously</li>
<li>Wallets can choose format based on user preference</li>
</ul>
<p><strong>Activation Timeline</strong>: TBD pending final specification
review.</p>
<h3 data-number="6.2.5"
id="sip-0006-native-src-20-amm-automated-market-maker"><span
class="header-section-number">6.2.5</span> 6.2.5 SIP-0006: Native SRC-20
AMM (Automated Market Maker)</h3>
<p><strong>GitHub Issue</strong>: <a
href="https://github.com/stampchain-io/btc_stamps/issues/689">#689</a></p>
<p><strong>Status</strong>: Draft (as of 2026-02)</p>
<p><strong>Motivation</strong>: Enable trustless on-chain token swaps
without order books or centralized exchanges. The account-based SRC-20
model is ideal for AMM implementation since balance updates are atomic
indexer operations, eliminating UTXO coordination complexity.</p>
<p><strong>Technical Design</strong>:</p>
<p>SIP-0006 introduces four new SRC-20 operations for constant product
market maker (Uniswap V2-style):</p>
<p><strong>1. <code>create_pool</code> — Deploy new liquidity
pool</strong>:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;p&quot;</span><span class="fu">:</span> <span class="st">&quot;src-20&quot;</span><span class="fu">,</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;op&quot;</span><span class="fu">:</span> <span class="st">&quot;create_pool&quot;</span><span class="fu">,</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;tick_a&quot;</span><span class="fu">:</span> <span class="st">&quot;KEVIN&quot;</span><span class="fu">,</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;tick_b&quot;</span><span class="fu">:</span> <span class="st">&quot;STAMP&quot;</span><span class="fu">,</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;fee_tier&quot;</span><span class="fu">:</span> <span class="dv">30</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<ul>
<li><strong>fee_tier</strong>: Fee in basis points (10 = 0.1%, 30 =
0.3%, 100 = 1.0%)</li>
<li>Creates LP token with tick: <code>LP:KEVIN/STAMP</code></li>
</ul>
<p><strong>2. <code>add_liquidity</code> — Deposit token pair to
pool</strong>:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;p&quot;</span><span class="fu">:</span> <span class="st">&quot;src-20&quot;</span><span class="fu">,</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;op&quot;</span><span class="fu">:</span> <span class="st">&quot;add_liquidity&quot;</span><span class="fu">,</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;pool&quot;</span><span class="fu">:</span> <span class="st">&quot;LP:KEVIN/STAMP&quot;</span><span class="fu">,</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;amt_a&quot;</span><span class="fu">:</span> <span class="st">&quot;1000&quot;</span><span class="fu">,</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;amt_b&quot;</span><span class="fu">:</span> <span class="st">&quot;5000&quot;</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<ul>
<li>Deposits proportional to current pool ratio</li>
<li>Mints LP tokens to liquidity provider</li>
<li>LP tokens are standard SRC-20 (transferable, tradeable)</li>
</ul>
<p><strong>3. <code>remove_liquidity</code> — Withdraw from
pool</strong>:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;p&quot;</span><span class="fu">:</span> <span class="st">&quot;src-20&quot;</span><span class="fu">,</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;op&quot;</span><span class="fu">:</span> <span class="st">&quot;remove_liquidity&quot;</span><span class="fu">,</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;pool&quot;</span><span class="fu">:</span> <span class="st">&quot;LP:KEVIN/STAMP&quot;</span><span class="fu">,</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;lp_amt&quot;</span><span class="fu">:</span> <span class="st">&quot;500&quot;</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<ul>
<li>Burns LP tokens</li>
<li>Returns proportional share of pool reserves</li>
</ul>
<p><strong>4. <code>swap</code> — Exchange tokens</strong>:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;p&quot;</span><span class="fu">:</span> <span class="st">&quot;src-20&quot;</span><span class="fu">,</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;op&quot;</span><span class="fu">:</span> <span class="st">&quot;swap&quot;</span><span class="fu">,</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;pool&quot;</span><span class="fu">:</span> <span class="st">&quot;LP:KEVIN/STAMP&quot;</span><span class="fu">,</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;from_tick&quot;</span><span class="fu">:</span> <span class="st">&quot;KEVIN&quot;</span><span class="fu">,</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;amt_in&quot;</span><span class="fu">:</span> <span class="st">&quot;100&quot;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p><strong>Swap Pricing Formula (Constant Product)</strong>:</p>
<pre><code>amt_out = (reserve_out × amt_in_with_fee) / (reserve_in + amt_in_with_fee)

where:
  amt_in_with_fee = amt_in × (10000 - fee_bps)

Example (0.3% fee tier):
  amt_in_with_fee = 100 × (10000 - 30) / 10000 = 99.7</code></pre>
<p><strong>LP Token Mechanics</strong>:</p>
<ul>
<li>LP tokens are standard SRC-20 tokens with tick format
<code>LP:{tick_a}/{tick_b}</code></li>
<li>Fully transferable between addresses</li>
<li>Can be traded on secondary markets</li>
<li>Mintable/burnable ONLY through AMM operations (add/remove
liquidity)</li>
<li>Represent proportional claim on pool reserves</li>
</ul>
<p><strong>Phased Rollout</strong>:</p>
<ul>
<li><strong>Phase 1</strong>: SRC-20/SRC-20 pools (fully trustless, no
external dependencies)</li>
<li><strong>Phase 2</strong>: wBTC pools (requires SIP-0007 wrapped
asset standard)</li>
<li><strong>Phase 3</strong>: Stablecoin pools (requires SIP-0003 bridge
for USDT/USDC)</li>
</ul>
<p><strong>Benefits</strong>:</p>
<ul>
<li><strong>Trustless</strong>: No intermediaries, no custody risk</li>
<li><strong>Permissionless</strong>: Anyone can create pools or provide
liquidity</li>
<li><strong>Atomic operations</strong>: Swaps execute in single indexer
transaction</li>
<li><strong>Capital efficient</strong>: Liquidity providers earn fees on
all trades</li>
</ul>
<p><strong>Challenges</strong>:</p>
<ul>
<li><strong>Impermanent loss</strong>: Liquidity providers exposed to
price divergence</li>
<li><strong>MEV risk</strong>: Indexer ordering can enable front-running
(mitigated by transaction fee priority)</li>
<li><strong>Pool fragmentation</strong>: Multiple fee tiers for same
pair splits liquidity</li>
</ul>
<p><strong>Activation Timeline</strong>: TBD pending community review
and Phase 1 implementation.</p>
<h3 data-number="6.2.6"
id="sip-0008-dual-transaction-parsing-combined-src-20-transfer-stamp-issuance"><span
class="header-section-number">6.2.6</span> 6.2.6 SIP-0008: Dual
Transaction Parsing — Combined SRC-20 Transfer + Stamp Issuance</h3>
<p><strong>GitHub Issue</strong>: <a
href="https://github.com/stampchain-io/btc_stamps/issues/692">#692</a>
(originated from <a
href="https://github.com/stampchain-io/btc_stamps/issues/554">#554</a>)</p>
<p><strong>Author</strong>: DerpHerpenstein</p>
<p><strong>Status</strong>: Draft</p>
<p><strong>Phase</strong>: 1 (Foundation) | <strong>Estimated
Effort</strong>: 2-3 weeks</p>
<p><strong>Motivation</strong>: Currently, a single Bitcoin transaction
can only perform one stamp operation — either issue a new stamp OR
execute an SRC-20 transfer. Users who want to do both must create two
separate transactions, paying double the fees. SIP-0008 enables a single
transaction to contain both a stamp issuance and an SRC-20 transfer,
reducing costs and enabling new composable workflows.</p>
<p><strong>Technical Design</strong>:</p>
<p>The indexer currently processes each transaction for a single stamp
operation. SIP-0008 extends the transaction parser to detect and process
multiple stamp payloads within a single transaction:</p>
<pre><code>Transaction outputs:
  Output 0: SRC-20 transfer payload (bare multisig or P2WSH)
  Output 1: Stamp image data (bare multisig or P2WSH)
  Output 2: Change output</code></pre>
<p><strong>Parsing Rules</strong>: 1. <strong>Output scanning</strong>:
Indexer scans all outputs for stamp-compatible payloads 2.
<strong>Payload classification</strong>: Each payload classified as
SRC-20 operation or stamp issuance based on content type detection 3.
<strong>Ordered execution</strong>: SRC-20 transfers processed before
stamp issuance (deterministic ordering) 4. <strong>Atomic
processing</strong>: Both operations succeed or both fail — no partial
execution 5. <strong>Backward compatibility</strong>: Single-operation
transactions continue to work unchanged</p>
<p><strong>Soft Dependency</strong>: SIP-0005 (Binary Transfer Format) —
binary encoding makes dual payloads more size-efficient, but SIP-0008
works with JSON encoding as well.</p>
<p><strong>Use Cases</strong>:</p>
<ul>
<li><strong>Mint-and-transfer</strong>: Create a stamp and immediately
send SRC-20 tokens in one transaction</li>
<li><strong>Composable workflows</strong>: Agent-driven pipelines that
batch stamp operations for efficiency</li>
<li><strong>Fee optimization</strong>: Single transaction fee instead of
two for combined operations</li>
</ul>
<p><strong>Activation Timeline</strong>: TBD pending community review
and Phase 1 implementation.</p>
<h2 data-number="6.3" id="superseded-sips"><span
class="header-section-number">6.3</span> 6.3 Superseded SIPs</h2>
<h3 data-number="6.3.1"
id="sip-0002-src-20-utxo-binding-transfer-format-v2.0"><span
class="header-section-number">6.3.1</span> 6.3.1 SIP-0002: SRC-20 UTXO
Binding &amp; Transfer Format v2.0</h3>
<p><strong>GitHub Issue</strong>: <a
href="https://github.com/stampchain-io/btc_stamps/issues/484">#484</a></p>
<p><strong>Status</strong>: Superseded (by SIP-0001)</p>
<p><strong>Original Motivation</strong>: Bind SRC-20 token balances to
specific Bitcoin UTXOs to enable single-transaction PSBT-based atomic
swaps without multi-step HTLC protocols.</p>
<p><strong>Proposed Design</strong>:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;p&quot;</span><span class="fu">:</span> <span class="st">&quot;src-20&quot;</span><span class="fu">,</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;op&quot;</span><span class="fu">:</span> <span class="st">&quot;bind_utxo&quot;</span><span class="fu">,</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;tick&quot;</span><span class="fu">:</span> <span class="st">&quot;KEVIN&quot;</span><span class="fu">,</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;amt&quot;</span><span class="fu">:</span> <span class="st">&quot;1000&quot;</span><span class="fu">,</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;utxo&quot;</span><span class="fu">:</span> <span class="st">&quot;txid:vout&quot;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<ul>
<li>Tokens would be locked to specific UTXO</li>
<li>Spending the UTXO would automatically transfer bound tokens</li>
<li>Enabled single-step atomic swaps via PSBT co-signing</li>
</ul>
<p><strong>Rejection Rationale</strong>:</p>
<ul>
<li><strong>Fundamental loss risk</strong>: If user spends bound UTXO in
normal Bitcoin transaction, SRC-20 tokens could be lost
<ul>
<li>Bitcoin consensus has no knowledge of SRC-20 state</li>
<li>Wallets cannot prevent accidental UTXO spending</li>
<li>Loss prevention is impossible without modifying Bitcoin
protocol</li>
</ul></li>
<li><strong>Non-deterministic rescue operations</strong>: Indexer “token
recovery” would break consensus determinism</li>
<li><strong>SIP-0001 provides superior solution</strong>: HTLC covers
all atomic swap use cases without loss risk</li>
<li><strong>Complexity vs benefit</strong>: UTXO coordination adds
significant implementation burden for marginal UX improvement</li>
</ul>
<p><strong>Superseded By</strong>: SIP-0001 (HTLC) provides trustless
atomic swaps without binding tokens to UTXOs, eliminating loss risk
while maintaining full functionality.</p>
<p><strong>Lessons Learned</strong>:</p>
<ul>
<li>Account-based models should not be forcibly bound to UTXO
mechanics</li>
<li>Protocol safety (loss prevention) outweighs UX convenience
(single-step swaps)</li>
<li>Multi-step protocols (HTLC) acceptable when they eliminate
fundamental risks</li>
</ul>
<h2 data-number="6.4" id="sip-process-best-practices"><span
class="header-section-number">6.4</span> 6.4 SIP Process Best
Practices</h2>
<h3 data-number="6.4.1" id="proposal-template"><span
class="header-section-number">6.4.1</span> 6.4.1 Proposal Template</h3>
<p><strong>Title</strong>: [SIP-XXXX] Brief descriptive title</p>
<p><strong>Author</strong>: GitHub username / contact info</p>
<p><strong>Status</strong>: Draft</p>
<p><strong>Type</strong>: Standards Track / Informational / Process</p>
<p><strong>Created</strong>: YYYY-MM-DD</p>
<p><strong>Sections</strong>: 1. <strong>Abstract</strong>:
One-paragraph summary 2. <strong>Motivation</strong>: Problem being
solved, use cases 3. <strong>Specification</strong>: Technical design,
data formats, validation rules 4. <strong>Rationale</strong>: Design
decisions, alternatives considered 5. <strong>Backward
Compatibility</strong>: Impact on existing stamps/indexers 6.
<strong>Test Cases</strong>: Reference implementation tests 7.
<strong>Security Considerations</strong>: Attack vectors, mitigations 8.
<strong>Activation</strong>: Proposed block height, coordination
plan</p>
<h3 data-number="6.4.2" id="review-criteria"><span
class="header-section-number">6.4.2</span> 6.4.2 Review Criteria</h3>
<p><strong>Technical Soundness</strong>:</p>
<ul>
<li>Specification is complete and unambiguous</li>
<li>Implementation is feasible with existing Bitcoin constraints</li>
<li>No cryptographic or protocol vulnerabilities</li>
</ul>
<p><strong>Protocol Alignment</strong>:</p>
<ul>
<li>Preserves UTXO-based permanence guarantees</li>
<li>Maintains account-based asset model</li>
<li>Follows Bitcoin-native encoding principles</li>
<li>Respects community governance values</li>
</ul>
<p><strong>Ecosystem Impact</strong>:</p>
<ul>
<li>Breaking changes justified and necessary</li>
<li>Migration path documented for affected users</li>
<li>Indexer implementation complexity is reasonable</li>
<li>Wallet/service integration burden is acceptable</li>
</ul>
<p><strong>Community Support</strong>:</p>
<ul>
<li>Rough consensus among developers</li>
<li>No strong objections from major stakeholders</li>
<li>Clear demand from users and builders</li>
</ul>
<h3 data-number="6.4.3" id="implementation-requirements"><span
class="header-section-number">6.4.3</span> 6.4.3 Implementation
Requirements</h3>
<p><strong>Reference Implementation</strong>: All accepted SIPs must
include:</p>
<ul>
<li>Working code in stampchain.io indexer repository</li>
<li>Comprehensive test suite with edge cases</li>
<li>Documentation for indexer operators</li>
<li>Example transactions on testnet</li>
</ul>
<p><strong>Multi-Indexer Compatibility</strong>: At least 2 independent
indexer implementations must successfully validate SIP test cases before
activation.</p>
<p><strong>Regression Testing</strong>: New SIP implementations must
pass full historical sync test (genesis block → current tip) without
breaking existing stamp validation.</p>
<h2 data-number="6.5" id="open-research-areas"><span
class="header-section-number">6.5</span> 6.5 Open Research Areas</h2>
<h3 data-number="6.5.1" id="zero-knowledge-proofs"><span
class="header-section-number">6.5.1</span> 6.5.1 Zero-Knowledge
Proofs</h3>
<p><strong>Research Question</strong>: Can zk-SNARKs enable private
SRC-20 transfers with succinct on-chain proofs?</p>
<p><strong>Potential Benefits</strong>:</p>
<ul>
<li>Strong privacy (ZCash-level confidentiality)</li>
<li>Compact proofs (200-500 bytes regardless of transfer
complexity)</li>
<li>Trustless verification by indexers</li>
</ul>
<p><strong>Challenges</strong>:</p>
<ul>
<li>Trusted setup requirements (or STARK alternatives)</li>
<li>Proof generation complexity for wallet implementations</li>
<li>Validation performance impact on indexer sync speed</li>
</ul>
<p><strong>Status</strong>: Exploratory research; no formal SIP yet.</p>
<h3 data-number="6.5.2" id="recursive-stamps-v2"><span
class="header-section-number">6.5.2</span> 6.5.2 Recursive Stamps
v2</h3>
<p><strong>Research Question</strong>: Can stamps reference external
Bitcoin data (taproot scripts, DLCs) to enable advanced smart
contracts?</p>
<p><strong>Potential Applications</strong>:</p>
<ul>
<li>Stamps triggered by DLC oracle outcomes</li>
<li>Integration with BitVM computation verification</li>
<li>Lightning Network settlement to stamp ownership</li>
</ul>
<p><strong>Challenges</strong>:</p>
<ul>
<li>Cross-protocol coordination complexity</li>
<li>Security assumptions for external data sources</li>
<li>Indexer validation of external state</li>
</ul>
<p><strong>Status</strong>: Concept phase; community feedback
sought.</p>
<h3 data-number="6.5.3" id="rollup-integration"><span
class="header-section-number">6.5.3</span> 6.5.3 Rollup Integration</h3>
<p><strong>Research Question</strong>: Can Bitcoin rollups (BitVM,
Sovereign SDK) support Stamps-compatible assets with L1 permanence
guarantees?</p>
<p><strong>Potential Architecture</strong>:</p>
<ul>
<li>L2 transactions executed off-chain</li>
<li>Periodic L1 commitment (Merkle root stamped on Bitcoin)</li>
<li>L2 state reconstructible from L1 commitments</li>
</ul>
<p><strong>Benefits</strong>:</p>
<ul>
<li>High throughput (1000s of transfers per second)</li>
<li>Low per-transfer cost (amortized L1 fees)</li>
<li>Maintained UTXO permanence for rollup commitments</li>
</ul>
<p><strong>Challenges</strong>:</p>
<ul>
<li>Data availability (ensure L2 state accessible)</li>
<li>Fraud proof mechanisms (dispute resolution)</li>
<li>Indexer complexity (track both L1 and L2 state)</li>
</ul>
<p><strong>Status</strong>: Monitoring BitVM development; formal SIP
pending rollup maturity.</p>
<hr />
<h2 data-number="6.6" id="sip-summary-table"><span
class="header-section-number">6.6</span> 6.6 SIP Summary Table</h2>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 14%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th>SIP</th>
<th>Title</th>
<th>Status</th>
<th>GitHub</th>
<th>Target Activation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>0001</strong></td>
<td>SRC-20 Conditional Transfers (HTLC)</td>
<td>Draft</td>
<td><a
href="https://github.com/stampchain-io/btc_stamps/issues/685">#685</a></td>
<td>TBD</td>
</tr>
<tr class="even">
<td><strong>0002</strong></td>
<td>SRC-20 UTXO Binding &amp; Transfer Format v2.0</td>
<td>Superseded (by SIP-0001)</td>
<td><a
href="https://github.com/stampchain-io/btc_stamps/issues/484">#484</a></td>
<td>N/A</td>
</tr>
<tr class="odd">
<td><strong>0003</strong></td>
<td>SRC-20 Cross-Chain Bridge Specification</td>
<td>Draft</td>
<td><a
href="https://github.com/stampchain-io/btc_stamps/issues/485">#485</a></td>
<td>TBD</td>
</tr>
<tr class="even">
<td><strong>0004</strong></td>
<td>Shielded SRC-20 — Privacy Extension</td>
<td>Draft</td>
<td><a
href="https://github.com/stampchain-io/btc_stamps/issues/687">#687</a></td>
<td>2027+ (phased)</td>
</tr>
<tr class="odd">
<td><strong>0005</strong></td>
<td>Binary Transfer Format for SRC-20</td>
<td>Draft</td>
<td><a
href="https://github.com/stampchain-io/btc_stamps/issues/688">#688</a></td>
<td>TBD</td>
</tr>
<tr class="even">
<td><strong>0006</strong></td>
<td>Native SRC-20 AMM (Automated Market Maker)</td>
<td>Draft</td>
<td><a
href="https://github.com/stampchain-io/btc_stamps/issues/689">#689</a></td>
<td>TBD</td>
</tr>
<tr class="odd">
<td><strong>0008</strong></td>
<td>Dual Transaction Parsing</td>
<td>Draft</td>
<td><a
href="https://github.com/stampchain-io/btc_stamps/issues/692">#692</a></td>
<td>TBD</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>References</strong>:</p>
<ul>
<li><a href="https://github.com/stampchain-io/btc_stamps">Bitcoin Stamps
GitHub Repository</a></li>
<li><a
href="https://github.com/stampchain-io/btc_stamps/issues/686">SIP-0000:
SIP Purpose and Guidelines</a></li>
<li><a href="https://github.com/CounterpartyXCP/cips">Counterparty
Improvement Proposals (CIPs)</a> — Inspiration for SIP governance
model</li>
</ul>
<hr />
<h1 data-number="7" id="implementation"><span
class="header-section-number">7</span> 7. Implementation</h1>
<h2 data-number="7.1" id="indexer-architecture"><span
class="header-section-number">7.1</span> 7.1 Indexer Architecture</h2>
<p>Bitcoin Stamps protocol relies on <strong>off-chain indexers</strong>
to parse stamp transactions, validate operations, and maintain asset
state. Unlike Bitcoin’s native UTXO consensus, stamp validity is
determined by indexer implementations following deterministic validation
rules.</p>
<h3 data-number="7.1.1" id="core-components"><span
class="header-section-number">7.1.1</span> 7.1.1 Core Components</h3>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                    INDEXER ARCHITECTURE                      │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌────────────────┐         ┌──────────────────┐           │
│  │  Bitcoin Node  │────────▶│  Block Parser    │           │
│  │  (RPC/REST)    │         │  (ZMQ listener)  │           │
│  └────────────────┘         └────────┬─────────┘           │
│                                       │                      │
│                            ┌──────────▼─────────┐           │
│                            │  Transaction       │           │
│                            │  Decoder           │           │
│                            │  (Multisig/P2WSH) │           │
│                            └──────────┬─────────┘           │
│                                       │                      │
│                   ┌───────────────────┼───────────────┐     │
│                   │                   │               │     │
│         ┌─────────▼────────┐  ┌──────▼──────┐  ┌────▼────┐│
│         │ SRC-20 Validator │  │ SRC-721     │  │ SRC-101 ││
│         │ (Token logic)    │  │ Validator   │  │ Validator││
│         └─────────┬────────┘  └──────┬──────┘  └────┬────┘│
│                   │                   │               │     │
│                   └───────────────────┼───────────────┘     │
│                                       │                      │
│                            ┌──────────▼─────────┐           │
│                            │  State Database    │           │
│                            │  (PostgreSQL/      │           │
│                            │   SQLite)          │           │
│                            └──────────┬─────────┘           │
│                                       │                      │
│                            ┌──────────▼─────────┐           │
│                            │  API Server        │           │
│                            │  (REST/GraphQL)    │           │
│                            └────────────────────┘           │
│                                                              │
└─────────────────────────────────────────────────────────────┘</code></pre>
<h3 data-number="7.1.2" id="block-processing-pipeline"><span
class="header-section-number">7.1.2</span> 7.1.2 Block Processing
Pipeline</h3>
<p><strong>1. Block Discovery</strong>:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ZMQ subscription for real-time blocks</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>zmq_socket.subscribe(<span class="st">&quot;hashblock&quot;</span>)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    block_hash <span class="op">=</span> zmq_socket.recv()</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    block <span class="op">=</span> bitcoin_rpc.getblock(block_hash, <span class="dv">2</span>)  <span class="co"># Verbosity 2: full tx data</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    process_block(block)</span></code></pre></div>
<p><strong>2. Transaction Filtering</strong>:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_stamp_transaction(tx):</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check for bare multisig outputs</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> vout <span class="kw">in</span> tx[<span class="st">&#39;vout&#39;</span>]:</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>        script <span class="op">=</span> vout[<span class="st">&#39;scriptPubKey&#39;</span>]</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> script[<span class="st">&#39;type&#39;</span>] <span class="op">==</span> <span class="st">&#39;multisig&#39;</span>:</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check for P2WSH outputs (OLGA)</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> script[<span class="st">&#39;type&#39;</span>] <span class="op">==</span> <span class="st">&#39;witness_v0_scripthash&#39;</span>:</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">False</span></span></code></pre></div>
<p><strong>3. Data Extraction</strong>:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extract_stamp_data(tx):</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    data_chunks <span class="op">=</span> []</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Bare multisig extraction</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> vout <span class="kw">in</span> tx[<span class="st">&#39;vout&#39;</span>]:</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> vout[<span class="st">&#39;scriptPubKey&#39;</span>][<span class="st">&#39;type&#39;</span>] <span class="op">==</span> <span class="st">&#39;multisig&#39;</span>:</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Extract fake pubkeys (33 bytes each)</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>            pubkeys <span class="op">=</span> vout[<span class="st">&#39;scriptPubKey&#39;</span>][<span class="st">&#39;asm&#39;</span>].split()</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> pk <span class="kw">in</span> pubkeys[<span class="dv">1</span>:<span class="op">-</span><span class="dv">2</span>]:  <span class="co"># Skip OP_1, OP_N, OP_CHECKMULTISIG</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>                data_chunks.append(<span class="bu">bytes</span>.fromhex(pk))</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># P2WSH witness extraction</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> vin <span class="kw">in</span> tx[<span class="st">&#39;vin&#39;</span>]:</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">&#39;txinwitness&#39;</span> <span class="kw">in</span> vin:</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>            witness_script <span class="op">=</span> vin[<span class="st">&#39;txinwitness&#39;</span>][<span class="op">-</span><span class="dv">1</span>]  <span class="co"># Last item is script</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Parse witness script for data chunks</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>            chunks <span class="op">=</span> parse_witness_script(witness_script)</span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>            data_chunks.extend(chunks)</span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Concatenate and decode</span></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>    raw_data <span class="op">=</span> <span class="st">b&#39;&#39;</span>.join(data_chunks)</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> decode_stamp_format(raw_data)</span></code></pre></div>
<p><strong>4. Validation</strong>:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> validate_stamp(tx, stamp_data, block_height):</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check format validity</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> is_valid_json(stamp_data):</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    parsed <span class="op">=</span> json.loads(stamp_data)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    protocol <span class="op">=</span> parsed.get(<span class="st">&#39;p&#39;</span>)</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Route to protocol-specific validator</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> protocol <span class="op">==</span> <span class="st">&#39;src-20&#39;</span>:</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> validate_src20(tx, parsed, block_height)</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> protocol <span class="op">==</span> <span class="st">&#39;src-721&#39;</span>:</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> validate_src721(tx, parsed, block_height)</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> protocol <span class="op">==</span> <span class="st">&#39;src-101&#39;</span>:</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> validate_src101(tx, parsed, block_height)</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Unknown protocol</span></span></code></pre></div>
<p><strong>5. State Update</strong>:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update_state(tx, stamp_data, block_height):</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    parsed <span class="op">=</span> json.loads(stamp_data)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> parsed[<span class="st">&#39;op&#39;</span>] <span class="op">==</span> <span class="st">&#39;deploy&#39;</span>:</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>        create_asset(parsed, tx.txid, block_height)</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> parsed[<span class="st">&#39;op&#39;</span>] <span class="op">==</span> <span class="st">&#39;mint&#39;</span>:</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>        increase_balance(</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>            address<span class="op">=</span>tx.sender_address,</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>            asset<span class="op">=</span>parsed[<span class="st">&#39;tick&#39;</span>],</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>            amount<span class="op">=</span>parsed[<span class="st">&#39;amt&#39;</span>]</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> parsed[<span class="st">&#39;op&#39;</span>] <span class="op">==</span> <span class="st">&#39;transfer&#39;</span>:</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>        transfer_balance(</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>            from_addr<span class="op">=</span>tx.sender_address,</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>            to_addr<span class="op">=</span>parsed[<span class="st">&#39;to&#39;</span>],</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>            asset<span class="op">=</span>parsed[<span class="st">&#39;tick&#39;</span>],</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>            amount<span class="op">=</span>parsed[<span class="st">&#39;amt&#39;</span>]</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>        )</span></code></pre></div>
<h3 data-number="7.1.3" id="state-database-schema"><span
class="header-section-number">7.1.3</span> 7.1.3 State Database
Schema</h3>
<p><strong>Core Tables</strong>:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Asset registry</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> assets (</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    asset_name TEXT <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    deploy_txid TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    deploy_block <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    deployer_address TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    max_supply <span class="dt">NUMERIC</span>,</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    divisible <span class="dt">BOOLEAN</span> <span class="kw">DEFAULT</span> <span class="kw">TRUE</span>,</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">locked</span> <span class="dt">BOOLEAN</span> <span class="kw">DEFAULT</span> <span class="kw">FALSE</span>,</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    metadata JSONB</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- Account balances (account-based model)</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> balances (</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    address TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>    asset TEXT <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">REFERENCES</span> assets(asset_name),</span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>    amount <span class="dt">NUMERIC</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">DEFAULT</span> <span class="dv">0</span>,</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>    last_updated_block <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">PRIMARY</span> <span class="kw">KEY</span> (address, asset)</span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- Transfer history</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> transfers (</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>    txid TEXT <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>    block_height <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">timestamp</span> <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>    from_address TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>    to_address TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>    asset TEXT <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">REFERENCES</span> assets(asset_name),</span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a>    amount <span class="dt">NUMERIC</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a>    status TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>  <span class="co">-- &#39;valid&#39;, &#39;invalid&#39;</span></span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a><span class="co">-- Stamp metadata</span></span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> stamps (</span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a>    stamp_id SERIAL <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a>    txid TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a>    block_height <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a>    cpid TEXT,  <span class="co">-- Counterparty asset ID (if legacy)</span></span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a>    stamp_url TEXT,</span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a>    stamp_hash TEXT,</span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a>    stamp_mimetype TEXT,</span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a>    supply <span class="dt">INTEGER</span> <span class="kw">DEFAULT</span> <span class="dv">1</span>,</span>
<span id="cb39-44"><a href="#cb39-44" aria-hidden="true" tabindex="-1"></a>    divisible <span class="dt">BOOLEAN</span> <span class="kw">DEFAULT</span> <span class="kw">FALSE</span>,</span>
<span id="cb39-45"><a href="#cb39-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">locked</span> <span class="dt">BOOLEAN</span> <span class="kw">DEFAULT</span> <span class="kw">FALSE</span>,</span>
<span id="cb39-46"><a href="#cb39-46" aria-hidden="true" tabindex="-1"></a>    creator_address TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-47"><a href="#cb39-47" aria-hidden="true" tabindex="-1"></a>    encoding TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>  <span class="co">-- &#39;multisig&#39;, &#39;p2wsh&#39;, &#39;olga&#39;</span></span>
<span id="cb39-48"><a href="#cb39-48" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb39-49"><a href="#cb39-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-50"><a href="#cb39-50" aria-hidden="true" tabindex="-1"></a><span class="co">-- SRC-721 compositions</span></span>
<span id="cb39-51"><a href="#cb39-51" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> src721_layers (</span>
<span id="cb39-52"><a href="#cb39-52" aria-hidden="true" tabindex="-1"></a>    composition_id TEXT <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb39-53"><a href="#cb39-53" aria-hidden="true" tabindex="-1"></a>    parent_stamp_ids <span class="dt">INTEGER</span>[] <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-54"><a href="#cb39-54" aria-hidden="true" tabindex="-1"></a>    layer_order <span class="dt">INTEGER</span>[] <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb39-55"><a href="#cb39-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">attributes</span> JSONB,</span>
<span id="cb39-56"><a href="#cb39-56" aria-hidden="true" tabindex="-1"></a>    rendered_hash TEXT</span>
<span id="cb39-57"><a href="#cb39-57" aria-hidden="true" tabindex="-1"></a>);</span></code></pre></div>
<h3 data-number="7.1.4" id="reorganization-handling"><span
class="header-section-number">7.1.4</span> 7.1.4 Reorganization
Handling</h3>
<p><strong>Challenge</strong>: Bitcoin can experience chain
reorganizations (reorgs) where blocks are replaced. Indexers must roll
back state and replay new chain.</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> handle_reorganization(old_tip_height, new_tip_height, fork_height):</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="co">    old_tip_height: Previous chain tip</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="co">    new_tip_height: New chain tip after reorg</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="co">    fork_height: Block where chains diverged</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Roll back state to fork point</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> db.transaction():</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Reverse all transfers after fork height</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>        reversed_transfers <span class="op">=</span> db.query(<span class="st">&quot;&quot;&quot;</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a><span class="st">            SELECT * FROM transfers</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a><span class="st">            WHERE block_height &gt; $1</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a><span class="st">            ORDER BY block_height DESC</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a><span class="st">        &quot;&quot;&quot;</span>, fork_height)</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> transfer <span class="kw">in</span> reversed_transfers:</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Undo transfer: reverse balance changes</span></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>            balances[transfer.from_address][transfer.asset] <span class="op">+=</span> transfer.amount</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>            balances[transfer.to_address][transfer.asset] <span class="op">-=</span> transfer.amount</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Delete rolled-back data</span></span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>        db.execute(<span class="st">&quot;DELETE FROM transfers WHERE block_height &gt; $1&quot;</span>, fork_height)</span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>        db.execute(<span class="st">&quot;DELETE FROM stamps WHERE block_height &gt; $1&quot;</span>, fork_height)</span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Replay blocks from new chain</span></span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> height <span class="kw">in</span> <span class="bu">range</span>(fork_height <span class="op">+</span> <span class="dv">1</span>, new_tip_height <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>        block_hash <span class="op">=</span> bitcoin_rpc.getblockhash(height)</span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>        block <span class="op">=</span> bitcoin_rpc.getblock(block_hash, <span class="dv">2</span>)</span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a>        process_block(block)</span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a>    logger.info(<span class="ss">f&quot;Reorg handled: fork at </span><span class="sc">{</span>fork_height<span class="sc">}</span><span class="ss">, replayed to </span><span class="sc">{</span>new_tip_height<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<p><strong>Detection</strong>:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> check_for_reorg(new_block):</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get current chain tip from DB</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    current_tip <span class="op">=</span> db.query(<span class="st">&quot;SELECT MAX(block_height) FROM transfers&quot;</span>).scalar()</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get parent of new block</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    new_block_parent <span class="op">=</span> new_block[<span class="st">&#39;previousblockhash&#39;</span>]</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if parent matches our current tip</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    expected_parent <span class="op">=</span> db.query(<span class="st">&quot;&quot;&quot;</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="st">        SELECT block_hash FROM blocks WHERE block_height = $1</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a><span class="st">    &quot;&quot;&quot;</span>, current_tip).scalar()</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> new_block_parent <span class="op">!=</span> expected_parent:</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Reorg detected - find fork point</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>        fork_height <span class="op">=</span> find_fork_point(new_block_parent)</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>        handle_reorganization(current_tip, new_block[<span class="st">&#39;height&#39;</span>], fork_height)</span></code></pre></div>
<h2 data-number="7.2" id="consensus-model"><span
class="header-section-number">7.2</span> 7.2 Consensus Model</h2>
<h3 data-number="7.2.1" id="deterministic-validation"><span
class="header-section-number">7.2.1</span> 7.2.1 Deterministic
Validation</h3>
<p><strong>Critical Property</strong>: All indexers processing the same
blockchain must arrive at identical state.</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Example: SRC-20 transfer validation must be deterministic</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> validate_src20_transfer(tx, parsed, block_height):</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Rule 1: Sender must have sufficient balance</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    sender <span class="op">=</span> tx.sender_address</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    asset <span class="op">=</span> parsed[<span class="st">&#39;tick&#39;</span>]</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    amount <span class="op">=</span> Decimal(parsed[<span class="st">&#39;amt&#39;</span>])</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> balances[sender][asset] <span class="op">&lt;</span> amount:</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Invalid: insufficient balance</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Rule 2: Asset must exist</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> asset_exists(asset):</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Invalid: unknown asset</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Rule 3: Asset must not be locked</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> assets[asset].locked:</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Invalid: asset locked</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Rule 4: Amount must respect divisibility</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> assets[asset].divisible <span class="kw">and</span> amount <span class="op">!=</span> <span class="bu">int</span>(amount):</span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Invalid: fractional amount for indivisible asset</span></span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># All rules pass</span></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span></code></pre></div>
<p><strong>Consensus Rules</strong>:</p>
<ul>
<li>Validation logic must be <strong>order-dependent</strong>: Process
transactions in block order</li>
<li>Floating-point arithmetic <strong>forbidden</strong>: Use
fixed-point decimals (Python <code>Decimal</code>)</li>
<li>No external data sources: Only blockchain data determines
validity</li>
<li>Edge cases must have <strong>defined behavior</strong>: No ambiguous
outcomes</li>
</ul>
<h3 data-number="7.2.2" id="first-seen-rule"><span
class="header-section-number">7.2.2</span> 7.2.2 First-Seen Rule</h3>
<p><strong>Problem</strong>: Multiple transactions in same block may
conflict (e.g., double-spend attempt).</p>
<p><strong>Solution</strong>: Process transactions in block order
(first-seen wins).</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> process_block(block):</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Process transactions in order (tx index 0, 1, 2, ...)</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> tx_index, tx <span class="kw">in</span> <span class="bu">enumerate</span>(block[<span class="st">&#39;tx&#39;</span>]):</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> is_stamp_transaction(tx):</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>            stamp_data <span class="op">=</span> extract_stamp_data(tx)</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Validate with current state</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> validate_stamp(tx, stamp_data, block[<span class="st">&#39;height&#39;</span>]):</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>                update_state(tx, stamp_data, block[<span class="st">&#39;height&#39;</span>])</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>                assign_stamp_number(tx.txid)  <span class="co"># Only valid stamps get numbers</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>                log_invalid_stamp(tx.txid, <span class="st">&quot;Validation failed&quot;</span>)</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Result: First valid transaction wins; later conflicts are invalid</span></span></code></pre></div>
<p><strong>Example</strong>:</p>
<pre><code>Block 900,000 contains:

- Tx A (index 5): Transfer 1000 KEVIN from Alice to Bob
- Tx B (index 12): Transfer 1000 KEVIN from Alice to Carol

Alice balance: 1000 KEVIN

Processing:
1. Tx A validated (Alice has 1000 KEVIN) → Alice: 0, Bob: 1000
2. Tx B validated (Alice has 0 KEVIN) → INVALID (insufficient balance)

Result: Bob receives 1000 KEVIN, Carol receives nothing</code></pre>
<h3 data-number="7.2.3" id="consensus-checkpoints"><span
class="header-section-number">7.2.3</span> 7.2.3 Consensus
Checkpoints</h3>
<p><strong>Purpose</strong>: Ensure indexer implementations agree on
historical state.</p>
<p><strong>Methodology</strong>: Community-generated state hashes at key
block heights.</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Checkpoint format</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>CHECKPOINTS <span class="op">=</span> {</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">796000</span>: {  <span class="co"># Counterparty cutoff block</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;state_hash&#39;</span>: <span class="st">&#39;a3f5c9e8d7b6...&#39;</span>,  <span class="co"># Hash of all balances at block 796000</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;total_stamps&#39;</span>: <span class="dv">18516</span>,</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;total_assets&#39;</span>: <span class="dv">142</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    },</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    <span class="dv">865000</span>: {  <span class="co"># OLGA activation block</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;state_hash&#39;</span>: <span class="st">&#39;e8d7b6a3f5c9...&#39;</span>,</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;total_stamps&#39;</span>: <span class="dv">45203</span>,</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">&#39;total_assets&#39;</span>: <span class="dv">387</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> verify_checkpoint(block_height):</span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> block_height <span class="kw">not</span> <span class="kw">in</span> CHECKPOINTS:</span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span>  <span class="co"># No checkpoint at this height</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute state hash</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>    current_state_hash <span class="op">=</span> compute_state_hash()</span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>    expected_hash <span class="op">=</span> CHECKPOINTS[block_height][<span class="st">&#39;state_hash&#39;</span>]</span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_state_hash <span class="op">!=</span> expected_hash:</span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> ConsensusError(</span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a>            <span class="ss">f&quot;State mismatch at block </span><span class="sc">{</span>block_height<span class="sc">}</span><span class="ss">: &quot;</span></span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a>            <span class="ss">f&quot;expected </span><span class="sc">{</span>expected_hash<span class="sc">}</span><span class="ss">, got </span><span class="sc">{</span>current_state_hash<span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a>    logger.info(<span class="ss">f&quot;Checkpoint verified at block </span><span class="sc">{</span>block_height<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_state_hash():</span>
<span id="cb45-33"><a href="#cb45-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Deterministic hash of all balances</span></span>
<span id="cb45-34"><a href="#cb45-34" aria-hidden="true" tabindex="-1"></a>    all_balances <span class="op">=</span> db.query(<span class="st">&quot;&quot;&quot;</span></span>
<span id="cb45-35"><a href="#cb45-35" aria-hidden="true" tabindex="-1"></a><span class="st">        SELECT address, asset, amount</span></span>
<span id="cb45-36"><a href="#cb45-36" aria-hidden="true" tabindex="-1"></a><span class="st">        FROM balances</span></span>
<span id="cb45-37"><a href="#cb45-37" aria-hidden="true" tabindex="-1"></a><span class="st">        ORDER BY address, asset</span></span>
<span id="cb45-38"><a href="#cb45-38" aria-hidden="true" tabindex="-1"></a><span class="st">    &quot;&quot;&quot;</span>).fetchall()</span>
<span id="cb45-39"><a href="#cb45-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-40"><a href="#cb45-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Serialize to JSON with sorted keys</span></span>
<span id="cb45-41"><a href="#cb45-41" aria-hidden="true" tabindex="-1"></a>    state_json <span class="op">=</span> json.dumps(all_balances, sort_keys<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb45-42"><a href="#cb45-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hashlib.sha256(state_json.encode()).hexdigest()</span></code></pre></div>
<h3 data-number="7.2.4" id="multi-indexer-consensus"><span
class="header-section-number">7.2.4</span> 7.2.4 Multi-Indexer
Consensus</h3>
<p><strong>Reference Implementations</strong>: 1.
<strong>stampchain.io</strong> (official): Python/Rust hybrid,
PostgreSQL backend 2. <strong>OpenStamps</strong> (community):
Independent implementation for validation 3. <strong>Alternative
indexers</strong>: Third-party implementations for redundancy</p>
<p><strong>Consensus Verification</strong>:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare indexer outputs at block height 900,000</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> https://stampchain.io/api/balances/bc1q...xyz<span class="pp">?</span>block=900000</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Response: {&quot;KEVIN&quot;: &quot;1000.0&quot;, &quot;STAMP&quot;: &quot;50.0&quot;}</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> https://openstamps.io/api/balances/bc1q...xyz<span class="pp">?</span>block=900000</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Response: {&quot;KEVIN&quot;: &quot;1000.0&quot;, &quot;STAMP&quot;: &quot;50.0&quot;}</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="co"># If outputs differ → consensus bug, investigation required</span></span></code></pre></div>
<p><strong>Divergence Protocol</strong>: 1. Community reports divergence
via GitHub Issue 2. Indexer operators freeze state at divergence block
3. Debug sessions compare validation logs step-by-step 4. Root cause
identified (usually edge case in validation logic) 5. Reference
implementation patched 6. All indexers update and re-sync from
divergence point</p>
<h2 data-number="7.3" id="validation-logic"><span
class="header-section-number">7.3</span> 7.3 Validation Logic</h2>
<h3 data-number="7.3.1" id="src-20-validation"><span
class="header-section-number">7.3.1</span> 7.3.1 SRC-20 Validation</h3>
<div class="sourceCode" id="cb47"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> validate_src20(tx, parsed, block_height):</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    op <span class="op">=</span> parsed.get(<span class="st">&#39;op&#39;</span>)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> op <span class="op">==</span> <span class="st">&#39;deploy&#39;</span>:</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> validate_src20_deploy(parsed, tx, block_height)</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> op <span class="op">==</span> <span class="st">&#39;mint&#39;</span>:</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> validate_src20_mint(parsed, tx, block_height)</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> op <span class="op">==</span> <span class="st">&#39;transfer&#39;</span>:</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> validate_src20_transfer(parsed, tx, block_height)</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Unknown operation</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> validate_src20_deploy(parsed, tx, block_height):</span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Required fields</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>    required <span class="op">=</span> [<span class="st">&#39;p&#39;</span>, <span class="st">&#39;op&#39;</span>, <span class="st">&#39;tick&#39;</span>, <span class="st">&#39;max&#39;</span>, <span class="st">&#39;lim&#39;</span>]</span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">all</span>(field <span class="kw">in</span> parsed <span class="cf">for</span> field <span class="kw">in</span> required):</span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ticker constraints</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>    tick <span class="op">=</span> parsed[<span class="st">&#39;tick&#39;</span>]</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> (<span class="dv">1</span> <span class="op">&lt;=</span> <span class="bu">len</span>(tick) <span class="op">&lt;=</span> <span class="dv">5</span>):  <span class="co"># 1-5 characters</span></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> tick.isupper():  <span class="co"># Uppercase only</span></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check uniqueness</span></span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> asset_exists(tick):</span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Duplicate ticker</span></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Supply constraints</span></span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>    max_supply <span class="op">=</span> Decimal(parsed[<span class="st">&#39;max&#39;</span>])</span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>    mint_limit <span class="op">=</span> Decimal(parsed[<span class="st">&#39;lim&#39;</span>])</span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> max_supply <span class="op">&lt;=</span> <span class="dv">0</span> <span class="kw">or</span> mint_limit <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mint_limit <span class="op">&gt;</span> max_supply:</span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-39"><a href="#cb47-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Counterparty cutoff rule</span></span>
<span id="cb47-40"><a href="#cb47-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> block_height <span class="op">&gt;</span> <span class="dv">796000</span>:</span>
<span id="cb47-41"><a href="#cb47-41" aria-hidden="true" tabindex="-1"></a>        <span class="co"># After block 796,000, must use native Bitcoin encoding</span></span>
<span id="cb47-42"><a href="#cb47-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> uses_counterparty_encoding(tx):</span>
<span id="cb47-43"><a href="#cb47-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb47-44"><a href="#cb47-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-45"><a href="#cb47-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb47-46"><a href="#cb47-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-47"><a href="#cb47-47" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> validate_src20_mint(parsed, tx, block_height):</span>
<span id="cb47-48"><a href="#cb47-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Asset must exist</span></span>
<span id="cb47-49"><a href="#cb47-49" aria-hidden="true" tabindex="-1"></a>    asset <span class="op">=</span> parsed[<span class="st">&#39;tick&#39;</span>]</span>
<span id="cb47-50"><a href="#cb47-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> asset_exists(asset):</span>
<span id="cb47-51"><a href="#cb47-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb47-52"><a href="#cb47-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-53"><a href="#cb47-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check supply constraints</span></span>
<span id="cb47-54"><a href="#cb47-54" aria-hidden="true" tabindex="-1"></a>    asset_info <span class="op">=</span> get_asset(asset)</span>
<span id="cb47-55"><a href="#cb47-55" aria-hidden="true" tabindex="-1"></a>    current_supply <span class="op">=</span> get_total_supply(asset)</span>
<span id="cb47-56"><a href="#cb47-56" aria-hidden="true" tabindex="-1"></a>    mint_amount <span class="op">=</span> Decimal(parsed[<span class="st">&#39;amt&#39;</span>])</span>
<span id="cb47-57"><a href="#cb47-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-58"><a href="#cb47-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Respect per-mint limit</span></span>
<span id="cb47-59"><a href="#cb47-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mint_amount <span class="op">&gt;</span> asset_info.mint_limit:</span>
<span id="cb47-60"><a href="#cb47-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb47-61"><a href="#cb47-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-62"><a href="#cb47-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Respect max supply</span></span>
<span id="cb47-63"><a href="#cb47-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> current_supply <span class="op">+</span> mint_amount <span class="op">&gt;</span> asset_info.max_supply:</span>
<span id="cb47-64"><a href="#cb47-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb47-65"><a href="#cb47-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-66"><a href="#cb47-66" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Asset must not be locked</span></span>
<span id="cb47-67"><a href="#cb47-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> asset_info.locked:</span>
<span id="cb47-68"><a href="#cb47-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb47-69"><a href="#cb47-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-70"><a href="#cb47-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb47-71"><a href="#cb47-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-72"><a href="#cb47-72" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> validate_src20_transfer(parsed, tx, block_height):</span>
<span id="cb47-73"><a href="#cb47-73" aria-hidden="true" tabindex="-1"></a>    sender <span class="op">=</span> tx.sender_address</span>
<span id="cb47-74"><a href="#cb47-74" aria-hidden="true" tabindex="-1"></a>    asset <span class="op">=</span> parsed[<span class="st">&#39;tick&#39;</span>]</span>
<span id="cb47-75"><a href="#cb47-75" aria-hidden="true" tabindex="-1"></a>    amount <span class="op">=</span> Decimal(parsed[<span class="st">&#39;amt&#39;</span>])</span>
<span id="cb47-76"><a href="#cb47-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-77"><a href="#cb47-77" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Asset must exist</span></span>
<span id="cb47-78"><a href="#cb47-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> asset_exists(asset):</span>
<span id="cb47-79"><a href="#cb47-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb47-80"><a href="#cb47-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-81"><a href="#cb47-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sender must have balance</span></span>
<span id="cb47-82"><a href="#cb47-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> get_balance(sender, asset) <span class="op">&lt;</span> amount:</span>
<span id="cb47-83"><a href="#cb47-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb47-84"><a href="#cb47-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-85"><a href="#cb47-85" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Amount must be positive</span></span>
<span id="cb47-86"><a href="#cb47-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> amount <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb47-87"><a href="#cb47-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb47-88"><a href="#cb47-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-89"><a href="#cb47-89" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Respect divisibility</span></span>
<span id="cb47-90"><a href="#cb47-90" aria-hidden="true" tabindex="-1"></a>    asset_info <span class="op">=</span> get_asset(asset)</span>
<span id="cb47-91"><a href="#cb47-91" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> asset_info.divisible:</span>
<span id="cb47-92"><a href="#cb47-92" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> amount <span class="op">!=</span> <span class="bu">int</span>(amount):</span>
<span id="cb47-93"><a href="#cb47-93" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span>  <span class="co"># No fractional amounts</span></span>
<span id="cb47-94"><a href="#cb47-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-95"><a href="#cb47-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span></code></pre></div>
<h3 data-number="7.3.2" id="src-721-validation"><span
class="header-section-number">7.3.2</span> 7.3.2 SRC-721 Validation</h3>
<div class="sourceCode" id="cb48"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> validate_src721(tx, parsed, block_height):</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Required fields</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">&#39;layers&#39;</span> <span class="kw">not</span> <span class="kw">in</span> parsed <span class="kw">or</span> <span class="kw">not</span> <span class="bu">isinstance</span>(parsed[<span class="st">&#39;layers&#39;</span>], <span class="bu">list</span>):</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Verify all referenced stamps exist</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> layer_stamp_id <span class="kw">in</span> parsed[<span class="st">&#39;layers&#39;</span>]:</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> stamp_exists(layer_stamp_id):</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Invalid: references non-existent stamp</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Layer count limits (prevent DOS via huge compositions)</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(parsed[<span class="st">&#39;layers&#39;</span>]) <span class="op">&gt;</span> <span class="dv">100</span>:</span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Optional attributes validation</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">&#39;attributes&#39;</span> <span class="kw">in</span> parsed:</span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(parsed[<span class="st">&#39;attributes&#39;</span>], <span class="bu">dict</span>):</span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span></code></pre></div>
<h3 data-number="7.3.3" id="encoding-detection"><span
class="header-section-number">7.3.3</span> 7.3.3 Encoding Detection</h3>
<div class="sourceCode" id="cb49"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> detect_encoding(tx):</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Determine stamp encoding method&quot;&quot;&quot;</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check for bare multisig</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> vout <span class="kw">in</span> tx[<span class="st">&#39;vout&#39;</span>]:</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> vout[<span class="st">&#39;scriptPubKey&#39;</span>][<span class="st">&#39;type&#39;</span>] <span class="op">==</span> <span class="st">&#39;multisig&#39;</span>:</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&#39;bare_multisig&#39;</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check for P2WSH (OLGA)</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> vout <span class="kw">in</span> tx[<span class="st">&#39;vout&#39;</span>]:</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> vout[<span class="st">&#39;scriptPubKey&#39;</span>][<span class="st">&#39;type&#39;</span>] <span class="op">==</span> <span class="st">&#39;witness_v0_scripthash&#39;</span>:</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Verify witness script contains stamp data</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> is_olga_format(tx):</span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="st">&#39;p2wsh_olga&#39;</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check for legacy Counterparty OP_RETURN</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> vout <span class="kw">in</span> tx[<span class="st">&#39;vout&#39;</span>]:</span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> vout[<span class="st">&#39;scriptPubKey&#39;</span>][<span class="st">&#39;type&#39;</span>] <span class="op">==</span> <span class="st">&#39;nulldata&#39;</span>:</span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> is_counterparty_format(tx):</span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="st">&#39;counterparty_op_return&#39;</span></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span>  <span class="co"># Not a stamp</span></span></code></pre></div>
<h2 data-number="7.4" id="performance-optimization"><span
class="header-section-number">7.4</span> 7.4 Performance
Optimization</h2>
<h3 data-number="7.4.1" id="rust-parser-integration"><span
class="header-section-number">7.4.1</span> 7.4.1 Rust Parser
Integration</h3>
<p><strong>Bottleneck</strong>: Python JSON parsing is slow for
high-volume indexing.</p>
<p><strong>Solution</strong>: Rust-based parser for critical path
(stampchain.io implementation).</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Rust: Fast binary parsing and validation</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> serde_json<span class="op">;</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> parse_stamp_data(raw_bytes<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">u8</span>]) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>StampData<span class="op">,</span> ParseError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Validate length prefix</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> expected_len <span class="op">=</span> <span class="dt">u16</span><span class="pp">::</span>from_be_bytes([raw_bytes[<span class="dv">0</span>]<span class="op">,</span> raw_bytes[<span class="dv">1</span>]])<span class="op">;</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> actual_len <span class="op">=</span> raw_bytes<span class="op">.</span>len() <span class="op">-</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> expected_len <span class="kw">as</span> <span class="dt">usize</span> <span class="op">!=</span> actual_len <span class="op">{</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="cn">Err</span>(<span class="pp">ParseError::</span>LengthMismatch)<span class="op">;</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Parse JSON (serde_json is 20-50x faster than Python)</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> json_data <span class="op">=</span> <span class="op">&amp;</span>raw_bytes[<span class="dv">2</span><span class="op">..</span>]<span class="op">;</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> parsed<span class="op">:</span> StampData <span class="op">=</span> <span class="pp">serde_json::</span>from_slice(json_data)<span class="op">?;</span></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(parsed)</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Performance Impact</strong>:</p>
<ul>
<li>Full chain sync (genesis → block 900,000): 3 hours (Rust) vs 48
hours (pure Python)</li>
<li>Real-time block processing: &lt;100ms per block (Rust) vs 1-3
seconds (Python)</li>
</ul>
<h3 data-number="7.4.2" id="database-indexing"><span
class="header-section-number">7.4.2</span> 7.4.2 Database Indexing</h3>
<div class="sourceCode" id="cb51"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Critical indexes for query performance</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_balances_address <span class="kw">ON</span> balances(address);</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_balances_asset <span class="kw">ON</span> balances(asset);</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_transfers_block_height <span class="kw">ON</span> transfers(block_height);</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_stamps_txid <span class="kw">ON</span> stamps(txid);</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_stamps_creator <span class="kw">ON</span> stamps(creator_address);</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- Composite indexes for common queries</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_transfers_asset_block <span class="kw">ON</span> transfers(asset, block_height);</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_balances_address_asset <span class="kw">ON</span> balances(address, asset);</span></code></pre></div>
<h3 data-number="7.4.3" id="caching-strategy"><span
class="header-section-number">7.4.3</span> 7.4.3 Caching Strategy</h3>
<div class="sourceCode" id="cb52"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co"># In-memory cache for hot data</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> lru_cache</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="at">@lru_cache</span>(maxsize<span class="op">=</span><span class="dv">10000</span>)</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_asset_info(asset_name):</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Cache asset metadata (rarely changes)&quot;&quot;&quot;</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> db.query(<span class="st">&quot;SELECT * FROM assets WHERE asset_name = $1&quot;</span>, asset_name)</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a><span class="at">@lru_cache</span>(maxsize<span class="op">=</span><span class="dv">100000</span>)</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> stamp_exists(stamp_id):</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Cache stamp existence checks&quot;&quot;&quot;</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> db.query(<span class="st">&quot;SELECT 1 FROM stamps WHERE stamp_id = $1&quot;</span>, stamp_id).scalar()</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Invalidate cache on state updates</span></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update_state(tx, stamp_data, block_height):</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... update database ...</span></span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Clear affected cache entries</span></span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> stamp_data[<span class="st">&#39;op&#39;</span>] <span class="op">==</span> <span class="st">&#39;deploy&#39;</span>:</span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a>        get_asset_info.cache_clear()  <span class="co"># New asset added</span></span></code></pre></div>
<h2 data-number="7.5" id="api-layer"><span
class="header-section-number">7.5</span> 7.5 API Layer</h2>
<h3 data-number="7.5.1" id="rest-endpoints"><span
class="header-section-number">7.5.1</span> 7.5.1 REST Endpoints</h3>
<div class="sourceCode" id="cb53"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Example API endpoints (stampchain.io)</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="at">@app.get</span>(<span class="st">&quot;/api/v1/balance/</span><span class="sc">{address}</span><span class="st">&quot;</span>)</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_balance(address: <span class="bu">str</span>, asset: <span class="bu">str</span> <span class="op">=</span> <span class="va">None</span>, block: <span class="bu">int</span> <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Get address balance(s) at specific block height&quot;&quot;&quot;</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> block:</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Historical balance query</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> query_balance_at_block(address, asset, block)</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Current balance</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> query_current_balance(address, asset)</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a><span class="at">@app.get</span>(<span class="st">&quot;/api/v1/asset/</span><span class="sc">{tick}</span><span class="st">&quot;</span>)</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_asset_info(tick: <span class="bu">str</span>):</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Get asset metadata&quot;&quot;&quot;</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;tick&quot;</span>: tick,</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;deploy_block&quot;</span>: assets[tick].deploy_block,</span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;max_supply&quot;</span>: assets[tick].max_supply,</span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;current_supply&quot;</span>: get_total_supply(tick),</span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;holders&quot;</span>: count_holders(tick),</span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;transfers&quot;</span>: count_transfers(tick)</span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a><span class="at">@app.get</span>(<span class="st">&quot;/api/v1/stamp/</span><span class="sc">{stamp_id}</span><span class="st">&quot;</span>)</span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_stamp(stamp_id: <span class="bu">int</span>):</span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Get stamp metadata and image data&quot;&quot;&quot;</span></span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a>    stamp <span class="op">=</span> db.query(<span class="st">&quot;SELECT * FROM stamps WHERE stamp_id = $1&quot;</span>, stamp_id)</span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;stamp_id&quot;</span>: stamp.stamp_id,</span>
<span id="cb53-31"><a href="#cb53-31" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;txid&quot;</span>: stamp.txid,</span>
<span id="cb53-32"><a href="#cb53-32" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;block_height&quot;</span>: stamp.block_height,</span>
<span id="cb53-33"><a href="#cb53-33" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;creator&quot;</span>: stamp.creator_address,</span>
<span id="cb53-34"><a href="#cb53-34" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;image_url&quot;</span>: stamp.stamp_url,</span>
<span id="cb53-35"><a href="#cb53-35" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;encoding&quot;</span>: stamp.encoding</span>
<span id="cb53-36"><a href="#cb53-36" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<h3 data-number="7.5.2" id="websocket-real-time-updates"><span
class="header-section-number">7.5.2</span> 7.5.2 WebSocket Real-Time
Updates</h3>
<div class="sourceCode" id="cb54"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> asyncio</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> websockets <span class="im">import</span> serve</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="cf">async</span> <span class="kw">def</span> stream_new_stamps(websocket):</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Stream newly confirmed stamps to connected clients&quot;&quot;&quot;</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>        new_stamp <span class="op">=</span> <span class="cf">await</span> stamp_queue.get()</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">await</span> websocket.send(json.dumps({</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;type&quot;</span>: <span class="st">&quot;new_stamp&quot;</span>,</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;stamp_id&quot;</span>: new_stamp.stamp_id,</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;txid&quot;</span>: new_stamp.txid,</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;block_height&quot;</span>: new_stamp.block_height</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>        }))</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Client usage:</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a><span class="co"># ws = new WebSocket(&quot;wss://stampchain.io/ws/stamps&quot;)</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a><span class="co"># ws.onmessage = (event) =&gt; { console.log(&quot;New stamp:&quot;, event.data) }</span></span></code></pre></div>
<hr />
<h2 data-number="7.6" id="implementation-summary"><span
class="header-section-number">7.6</span> 7.6 Implementation Summary</h2>
<p><strong>Architecture</strong>: Off-chain indexers parse Bitcoin
blockchain and maintain asset state in deterministic, verifiable
manner.</p>
<p><strong>Consensus</strong>: No on-chain enforcement—indexers
independently validate and must agree on state through deterministic
rules.</p>
<p><strong>Activation Lead Time</strong>: Protocol upgrades (SIPs)
require 4+ weeks notice, specified as activation block height.</p>
<p><strong>Performance</strong>: Hybrid Python/Rust implementation
achieves full chain sync in ~3 hours; real-time processing &lt;100ms per
block.</p>
<p><strong>Redundancy</strong>: Multiple independent indexer
implementations prevent single point of failure; community checkpoints
ensure consensus.</p>
<hr />
<p><strong>References</strong>:</p>
<ul>
<li><a href="https://github.com/stampchain-io/btc_stamps">stampchain.io
Indexer Source Code</a></li>
<li><a href="https://github.com/openstamps/indexer">OpenStamps
Independent Implementation</a></li>
<li><a href="https://developer.bitcoin.org/reference/rpc/">Bitcoin Core
RPC Documentation</a></li>
<li><a
href="https://github.com/bitcoin/bitcoin/blob/master/doc/zmq.md">ZMQ
Block Notifications</a></li>
</ul>
<hr />
<h1 data-number="8" id="security-analysis"><span
class="header-section-number">8</span> 8. Security Analysis</h1>
<h2 data-number="8.1" id="immutability-guarantees"><span
class="header-section-number">8.1</span> 8.1 Immutability
Guarantees</h2>
<p>Bitcoin Stamps’ security model is fundamentally derived from its
UTXO-based storage architecture. This section analyzes the threat model,
attack vectors, and security properties inherited from Bitcoin.</p>
<h3 data-number="8.1.1" id="utxo-set-permanence"><span
class="header-section-number">8.1.1</span> 8.1.1 UTXO Set
Permanence</h3>
<p><strong>Security Property</strong>: Once a stamp transaction is
confirmed in a Bitcoin block with sufficient depth, the embedded data is
<strong>effectively immutable</strong> and
<strong>unprunable</strong>.</p>
<p><strong>Mechanism</strong>:</p>
<pre><code>Stamp Transaction (Block N)
    ↓
Bitcoin Miners Confirm (6+ confirmations)
    ↓
UTXO Created (scriptPubKey contains stamp data)
    ↓
Full Nodes Store UTXO (required for validation)
    ↓
Data Persists (unprunable consensus-critical data)</code></pre>
<p><strong>Proof-of-Work Protection</strong>:</p>
<ul>
<li>To reverse a stamp (via blockchain reorganization), attacker must:
<ol type="1">
<li>Mine competing chain longer than confirmed depth</li>
<li>Accumulate more proof-of-work than honest network</li>
<li>Sustain 51% hashrate majority for extended period</li>
</ol></li>
</ul>
<p><strong>Cost Analysis</strong> (6 confirmations = ~1 hour):</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Attack cost to reverse 6-block-deep stamp (as of 2026)</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>network_hashrate <span class="op">=</span> <span class="dv">600_000_000</span> TH<span class="op">/</span>s  <span class="co"># ~600 exahash/s</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>block_reward <span class="op">=</span> <span class="fl">3.125</span> BTC  <span class="co"># Post-2024 halving</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>btc_price <span class="op">=</span> <span class="dv">60000</span>  <span class="co"># USD</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Minimum cost to mine 7 blocks (replace 6 + extend by 1)</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>attack_cost <span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> block_reward <span class="op">*</span> btc_price</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>attack_cost <span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> <span class="fl">3.125</span> <span class="op">*</span> <span class="dv">60000</span> <span class="op">=</span> $<span class="dv">1</span>,<span class="dv">312</span>,<span class="dv">500</span> USD</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Reality: Requires acquiring 51% hashrate hardware (billions USD)</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Practical cost &gt;&gt; $1M due to hardware, electricity, opportunity cost</span></span></code></pre></div>
<p><strong>Result</strong>: Reversing confirmed stamps is economically
infeasible for rational attackers.</p>
<h3 data-number="8.1.2" id="utxo-vs-witness-data"><span
class="header-section-number">8.1.2</span> 8.1.2 UTXO vs Witness
Data</h3>
<p><strong>Critical Distinction</strong>: Bitcoin Stamps store data in
UTXO set, NOT witness data.</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 40%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th>Property</th>
<th>UTXO Set Data (Stamps)</th>
<th>Witness Data (Ordinals)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Required for validation</strong></td>
<td>✅ Yes (spending UTXO)</td>
<td>❌ No (signature verification only)</td>
</tr>
<tr class="even">
<td><strong>Prunable by nodes</strong></td>
<td>❌ No (breaks validation)</td>
<td>✅ Yes (after tx validation)</td>
</tr>
<tr class="odd">
<td><strong>Consensus-critical</strong></td>
<td>✅ Yes</td>
<td>⚠️ Partial (not for future txs)</td>
</tr>
<tr class="even">
<td><strong>Archival dependency</strong></td>
<td>❌ None (all full nodes)</td>
<td>⚠️ Requires archival nodes</td>
</tr>
<tr class="odd">
<td><strong>Long-term permanence</strong></td>
<td>✅ Guaranteed</td>
<td>⚠️ Dependent on node policies</td>
</tr>
</tbody>
</table>
<p><strong>Security Implication</strong>: Stamps data survives even
if:</p>
<ul>
<li>Archival nodes stop operating</li>
<li>Witness data is pruned by majority of nodes</li>
<li>Protocol indexers cease operation</li>
</ul>
<p><strong>Threat Scenario Analysis</strong>:</p>
<p><em>Scenario 1: Ordinals data loss</em></p>
<pre><code>Year 2035: Bitcoin Core default config prunes witness data after 1 year
→ Majority of nodes delete old Ordinals inscription data
→ Only archival nodes retain full witness history
→ If archival nodes shut down, inscription data is lost
→ Ordinals become unrecoverable</code></pre>
<p><em>Scenario 2: Stamps resilience</em></p>
<pre><code>Year 2035: Same pruning scenario
→ Stamps data is in UTXO set (unprunable)
→ All full nodes retain stamp data (required for validation)
→ No dependency on archival nodes
→ Stamps remain permanently accessible</code></pre>
<h3 data-number="8.1.3" id="utxo-spending-risk"><span
class="header-section-number">8.1.3</span> 8.1.3 UTXO Spending Risk</h3>
<p><strong>Vulnerability</strong>: If stamp-bearing UTXO is spent, data
remains in blockchain history but exits active UTXO set.</p>
<p><strong>Mitigation</strong>: Stamp protocol uses <strong>economically
unspendable UTXOs</strong>:</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Example stamp output</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>scriptPubKey: OP_1 <span class="op">&lt;</span>fake_pubkey_1<span class="op">&gt;</span> <span class="op">&lt;</span>fake_pubkey_2<span class="op">&gt;</span> <span class="op">&lt;</span>real_pubkey<span class="op">&gt;</span> OP_3 OP_CHECKMULTISIG</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>value: <span class="dv">546</span> satoshis  <span class="co"># Dust limit</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Spending cost analysis</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>input_size <span class="op">=</span> <span class="dv">150</span> <span class="bu">bytes</span>  <span class="co"># Approx size to spend this UTXO</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>fee_rate <span class="op">=</span> <span class="dv">20</span> sat<span class="op">/</span>vByte  <span class="co"># Typical fee rate</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>spend_cost <span class="op">=</span> <span class="dv">150</span> <span class="op">*</span> <span class="dv">20</span> <span class="op">=</span> <span class="dv">3000</span> satoshis</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Economic rationality</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>output_value <span class="op">=</span> <span class="dv">546</span> sats</span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>spend_cost <span class="op">=</span> <span class="dv">3000</span> sats</span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>net_loss <span class="op">=</span> <span class="dv">2454</span> sats</span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Conclusion: Economically irrational to spend (lose money)</span></span></code></pre></div>
<p><strong>Result</strong>: Stamp UTXOs are <strong>economically
unspendable</strong> under normal fee markets, ensuring perpetual UTXO
set residence.</p>
<p><strong>Exception</strong>: During extremely low fee periods (&lt;1
sat/vByte), spending may become economically viable. However:</p>
<ul>
<li>Most stamp creators use addresses without private keys (burn
addresses)</li>
<li>Community norm: Do not spend stamp UTXOs</li>
<li>Even if spent, data remains in blockchain history (recoverable via
archival indexing)</li>
</ul>
<h3 data-number="8.1.4" id="consensus-layer-protection"><span
class="header-section-number">8.1.4</span> 8.1.4 Consensus-Layer
Protection</h3>
<p><strong>Property</strong>: Stamps inherit Bitcoin’s Proof-of-Work
security.</p>
<p><strong>Attack Resistance</strong>: 1. <strong>51% Attack</strong>:
Requires sustained majority hashrate control (&gt;$10B hardware
investment) 2. <strong>Sybil Attack</strong>: PoW makes creating fake
blocks prohibitively expensive 3. <strong>Eclipse Attack</strong>: Does
not affect confirmed stamp data (only network propagation) 4.
<strong>Censorship</strong>: Miners can censor new stamps, but cannot
erase confirmed ones</p>
<p><strong>Finality</strong>: After ~6 confirmations (~1 hour), stamp
data has same security as Bitcoin monetary transactions. No known attack
can reverse deeply confirmed stamps without breaking Bitcoin itself.</p>
<h2 data-number="8.2" id="indexer-security-model"><span
class="header-section-number">8.2</span> 8.2 Indexer Security Model</h2>
<h3 data-number="8.2.1" id="trust-assumptions"><span
class="header-section-number">8.2.1</span> 8.2.1 Trust Assumptions</h3>
<p><strong>Centralization Risk</strong>: Unlike Bitcoin’s native
consensus, stamp <em>validity</em> is determined by off-chain
indexers.</p>
<p><strong>Trust Model</strong>:</p>
<pre><code>Bitcoin Layer: Trustless (PoW consensus)
    ↓ (data storage)
Stamp Data: Permanently stored (guaranteed)
    ↓ (interpretation)
Indexer Layer: Trust-minimized (open-source, multi-implementation)
    ↓ (presentation)
Application Layer: Varies (wallet/explorer trust)</code></pre>
<p><strong>Key Insight</strong>: Users must trust indexer <em>validation
logic</em>, not data availability. Data is guaranteed by Bitcoin; only
interpretation requires indexer trust.</p>
<h3 data-number="8.2.2" id="indexer-attack-vectors"><span
class="header-section-number">8.2.2</span> 8.2.2 Indexer Attack
Vectors</h3>
<p><strong>Attack 1: Malicious Indexer</strong></p>
<p><em>Scenario</em>: Rogue indexer reports false balances.</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Honest indexer</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>get_balance(<span class="st">&quot;bc1q...xyz&quot;</span>, <span class="st">&quot;KEVIN&quot;</span>) → <span class="dv">1000</span> KEVIN</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Malicious indexer</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>get_balance(<span class="st">&quot;bc1q...xyz&quot;</span>, <span class="st">&quot;KEVIN&quot;</span>) → <span class="dv">999999</span> KEVIN  <span class="co"># False balance</span></span></code></pre></div>
<p><em>Mitigation</em>: 1. <strong>Multi-indexer verification</strong>:
Users query multiple independent indexers 2. <strong>Open-source
validation</strong>: Anyone can verify balances by running own indexer
3. <strong>Consensus checkpoints</strong>: Community-verified state
hashes at key blocks 4. <strong>Reputation systems</strong>: Wallets
prioritize trusted indexers (stampchain.io, OpenStamps)</p>
<p><em>Result</em>: Attack detected when balances diverge across
indexers. Malicious indexer loses reputation; honest indexers remain
authoritative.</p>
<p><strong>Attack 2: State Divergence Bug</strong></p>
<p><em>Scenario</em>: Bug in indexer code causes state divergence across
implementations.</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Indexer A (buggy edge case handling)</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>process_transfer(amount<span class="op">=</span><span class="st">&quot;1000.00000001&quot;</span>)  <span class="co"># Accepts fractional indivisible token</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>→ balance_A[<span class="st">&quot;KEVIN&quot;</span>] <span class="op">=</span> <span class="fl">1000.00000001</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Indexer B (correct validation)</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>process_transfer(amount<span class="op">=</span><span class="st">&quot;1000.00000001&quot;</span>)  <span class="co"># Rejects invalid transfer</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>→ balance_B[<span class="st">&quot;KEVIN&quot;</span>] <span class="op">=</span> <span class="dv">1000</span></span></code></pre></div>
<p><em>Detection</em>:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Community monitoring</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> https://stampchain.io/api/balance/bc1q...xyz → {<span class="st">&quot;KEVIN&quot;</span>: <span class="st">&quot;1000.00000001&quot;</span>}</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> https://openstamps.io/api/balance/bc1q...xyz → {<span class="st">&quot;KEVIN&quot;</span>: <span class="st">&quot;1000&quot;</span>}</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Divergence alert triggered</span></span></code></pre></div>
<p><em>Mitigation</em>: 1. <strong>Consensus checkpoints</strong>:
Pre-computed state hashes at milestone blocks 2. <strong>Test
suites</strong>: Comprehensive edge case testing 3.
<strong>Multi-language implementations</strong>: Python, Rust, Go reduce
likelihood of identical bugs 4. <strong>Bug bounty programs</strong>:
Incentivize discovery and reporting</p>
<p><em>Resolution</em>: 1. Freeze indexer state at divergence block 2.
Debug session: Compare validation logs transaction-by-transaction 3.
Identify root cause (usually edge case in validation logic) 4. Patch
reference implementation 5. All indexers re-sync from divergence point
6. Community consensus on canonical state</p>
<p><strong>Attack 3: Eclipse Attack on Indexer</strong></p>
<p><em>Scenario</em>: Attacker isolates indexer’s Bitcoin node, feeds
fake blocks.</p>
<pre><code>Attacker → Fake Bitcoin blocks → Isolated indexer node → False stamp state</code></pre>
<p><em>Mitigation</em>: 1. <strong>Multiple Bitcoin node
connections</strong>: Indexer connects to diverse nodes 2.
<strong>Checkpoint validation</strong>: Verify block hashes match known
checkpoints 3. <strong>Network diversity</strong>: Connect to nodes
across different ISPs, geolocations 4. <strong>Block header
verification</strong>: Validate cumulative PoW matches expected
difficulty</p>
<p><em>Result</em>: Isolated indexer detects anomaly (PoW mismatch,
checkpoint failure) and alerts operator.</p>
<h3 data-number="8.2.3" id="data-availability"><span
class="header-section-number">8.2.3</span> 8.2.3 Data Availability</h3>
<p><strong>Property</strong>: Stamp data is available as long as Bitcoin
network operates.</p>
<p><strong>Availability Guarantees</strong>: 1. <strong>Full
Nodes</strong>: ~50,000 Bitcoin full nodes globally store UTXO set 2.
<strong>Geographic Distribution</strong>: Nodes across 100+ countries 3.
<strong>Independent Operators</strong>: Diverse node operators (mining
pools, exchanges, enthusiasts) 4. <strong>Redundancy</strong>: Single
node failure has no impact (1000s of backups)</p>
<p><strong>Failure Scenario Analysis</strong>:</p>
<p><em>Scenario: All indexers shut down</em></p>
<pre><code>→ Stamp data remains in Bitcoin UTXO set (unchanged)
→ Any party can launch new indexer, sync from genesis
→ Asset balances reconstructible from blockchain
→ Protocol continues functioning (trustless recovery)</code></pre>
<p><em>Scenario: Catastrophic Bitcoin network failure</em></p>
<pre><code>→ If Bitcoin dies, stamps die with it (accepted risk)
→ No protocol can survive underlying blockchain failure
→ Stamps permanence = Bitcoin permanence (aligned incentives)</code></pre>
<h2 data-number="8.3" id="protocol-specific-vulnerabilities"><span
class="header-section-number">8.3</span> 8.3 Protocol-Specific
Vulnerabilities</h2>
<h3 data-number="8.3.1" id="front-running-attacks"><span
class="header-section-number">8.3.1</span> 8.3.1 Front-Running
Attacks</h3>
<p><strong>Vulnerability</strong>: Attacker observes pending stamp
transaction (mempool), submits higher-fee competing transaction.</p>
<p><em>Example</em>:</p>
<pre><code>Alice broadcasts: MINT 1000 KEVIN (fee: 10 sat/vByte)
    ↓ (mempool)
Bob observes transaction, broadcasts: MINT 1000 KEVIN (fee: 50 sat/vByte)
    ↓ (next block)
Bob&#39;s transaction confirms first → Bob receives KEVIN
Alice&#39;s transaction confirms second → Alice receives nothing (max supply reached)</code></pre>
<p><strong>Mitigation</strong>: 1. <strong>Privacy</strong>: Use private
transaction relay (direct miner submission) 2. <strong>High
fees</strong>: Pay competitive fee rate to discourage front-running 3.
<strong>MEV-resistance</strong>: SRC-20 minting is
first-come-first-served (no extractable value in ordering) 4.
<strong>Batch minting</strong>: Deploy + mint in same transaction
(atomic operation)</p>
<p><strong>Limitation</strong>: Front-running is inherent to public
mempool. Complete mitigation requires private mempools
(availability/centralization tradeoff).</p>
<h3 data-number="8.3.2" id="replay-attacks"><span
class="header-section-number">8.3.2</span> 8.3.2 Replay Attacks</h3>
<p><strong>Vulnerability</strong>: Reuse of stamp transaction on chain
forks (e.g., contentious hard fork).</p>
<p><em>Scenario</em>:</p>
<pre><code>Bitcoin forks into Chain A and Chain B
Alice&#39;s stamp transaction valid on both chains
→ Stamp created on Chain A
→ Same stamp replayed on Chain B (unintended duplication)</code></pre>
<p><strong>Mitigation</strong>: 1. <strong>Chain-specific
indexers</strong>: Community designates canonical chain (longest PoW) 2.
<strong>Replay protection</strong>: Future SIPs may include chain ID in
transactions 3. <strong>Economic disincentive</strong>: Forked chains
typically have low value (no incentive to replay)</p>
<p><strong>Historical Example</strong>: Bitcoin Cash (2017) and Bitcoin
SV (2018) forks had separate Counterparty ecosystems. No significant
stamp replay issues due to community consensus on Bitcoin mainnet.</p>
<h3 data-number="8.3.3" id="ticker-squatting"><span
class="header-section-number">8.3.3</span> 8.3.3 Ticker Squatting</h3>
<p><strong>Vulnerability</strong>: Malicious actor deploys popular
ticker before legitimate project.</p>
<p><em>Example</em>:</p>
<pre><code>Attacker deploys &quot;STAMP&quot; token (malicious)
    ↓ (1 month later)
Legitimate STAMP project launches
    ↓ (ticker already taken)
Legitimate project must use alternative ticker (&quot;STAMP2&quot;, &quot;STMP&quot;)</code></pre>
<p><strong>Mitigation</strong>: 1.
<strong>First-come-first-served</strong>: Protocol design accepts ticker
squatting as valid 2. <strong>Community curation</strong>:
Indexers/wallets flag known malicious tickers 3. <strong>Metadata
verification</strong>: Users verify deploy block, deployer address 4.
<strong>Naming services</strong>: SRC-101 enables human-readable names
(alternative to tickers) 5. <strong>Social consensus</strong>: Community
recognizes legitimate projects regardless of ticker</p>
<p><strong>Accepted Risk</strong>: Bitcoin Stamps follows permissionless
ethos—anyone can deploy any ticker. Scam prevention is
social/application layer responsibility, not protocol enforcement.</p>
<h3 data-number="8.3.4" id="dust-attack"><span
class="header-section-number">8.3.4</span> 8.3.4 Dust Attack</h3>
<p><strong>Vulnerability</strong>: Attacker sends tiny stamp token
amounts to many addresses, tracking UTXO linkage.</p>
<p><em>Example</em>:</p>
<pre><code>Attacker sends 0.00000001 KEVIN to 10,000 addresses
    ↓
Tracks which addresses consolidate UTXOs (reveals address clustering)
    ↓
Deanonymizes user identity via address linkage</code></pre>
<p><strong>Mitigation</strong>: 1. <strong>Ignore dust</strong>: Wallets
can hide balances below threshold 2. <strong>Coin control</strong>:
Users avoid consolidating dust with main balance 3. <strong>Privacy
protocols</strong>: SIP-0004 (confidential transfers) breaks linkage 4.
<strong>CoinJoin integration</strong>: Mix UTXOs before
consolidation</p>
<p><strong>Limitation</strong>: Account-based model means dust tokens
don’t create on-chain linkage (no UTXOs to track). Dust attack less
effective against stamps than UTXO-based tokens.</p>
<h2 data-number="8.4" id="attack-cost-analysis"><span
class="header-section-number">8.4</span> 8.4 Attack Cost Analysis</h2>
<h3 data-number="8.4.1" id="stamp-reversal-attack"><span
class="header-section-number">8.4.1</span> 8.4.1 Stamp Reversal
Attack</h3>
<p><strong>Goal</strong>: Delete or modify confirmed stamp data.</p>
<p><strong>Required Attack</strong>: 51% attack on Bitcoin network.</p>
<p><strong>Cost</strong> (as of 2026):</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Current Bitcoin hashrate</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>total_hashrate <span class="op">=</span> <span class="dv">600_000_000</span> TH<span class="op">/</span>s  <span class="co"># 600 exahash/s</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="co"># To achieve 51% majority</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>required_hashrate <span class="op">=</span> <span class="dv">600_000_000</span> <span class="op">*</span> <span class="fl">0.51</span> <span class="op">/</span> <span class="fl">0.49</span> <span class="op">=</span> <span class="dv">624_489_796</span> TH<span class="op">/</span>s</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Hardware cost (Antminer S19 XP: 140 TH/s, $5000 each)</span></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>miners_needed <span class="op">=</span> <span class="dv">624_489_796</span> <span class="op">/</span> <span class="dv">140</span> <span class="op">=</span> <span class="dv">4</span>,<span class="dv">460</span>,<span class="dv">641</span> miners</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>hardware_cost <span class="op">=</span> <span class="dv">4</span>,<span class="dv">460</span>,<span class="dv">641</span> <span class="op">*</span> <span class="dv">5000</span> <span class="op">=</span> $<span class="dv">22</span>,<span class="dv">303</span>,<span class="dv">205</span>,<span class="dv">000</span> (<span class="op">~</span>$<span class="dv">22</span> billion USD)</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Operational cost (electricity: $0.05/kWh, 3.25 kW per miner)</span></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>daily_power_cost <span class="op">=</span> <span class="dv">4</span>,<span class="dv">460</span>,<span class="dv">641</span> <span class="op">*</span> <span class="fl">3.25</span> <span class="op">*</span> <span class="dv">24</span> <span class="op">*</span> <span class="fl">0.05</span> <span class="op">=</span> $<span class="dv">17</span>,<span class="dv">344</span>,<span class="dv">000</span><span class="op">/</span>day</span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Attack duration to reverse 6-deep stamp</span></span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a>attack_duration <span class="op">=</span> <span class="dv">1</span> hour (mine <span class="dv">7</span> blocks)</span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>attack_cost <span class="op">=</span> $<span class="fl">22.3</span><span class="er">B</span> (hardware) <span class="op">+</span> $<span class="dv">720</span><span class="er">k</span> (electricity) ≈ $<span class="fl">22.3</span> billion</span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Opportunity cost (forgoing legitimate mining revenue)</span></span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a>blocks_mined <span class="op">=</span> <span class="dv">7</span></span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a>revenue_lost <span class="op">=</span> <span class="dv">7</span> <span class="op">*</span> <span class="fl">3.125</span> BTC <span class="op">*</span> $<span class="dv">60</span>,<span class="dv">000</span> <span class="op">=</span> $<span class="dv">1</span>,<span class="dv">312</span>,<span class="dv">500</span></span></code></pre></div>
<p><strong>Total Attack Cost</strong>: ~$22 billion USD (hardware) +
ongoing electricity + lost revenue.</p>
<p><strong>Conclusion</strong>: Economically irrational for all but
nation-state attackers. Stamp data is secured by Bitcoin’s cumulative
PoW.</p>
<h3 data-number="8.4.2" id="indexer-manipulation-attack"><span
class="header-section-number">8.4.2</span> 8.4.2 Indexer Manipulation
Attack</h3>
<p><strong>Goal</strong>: Trick users into accepting false stamp
balances.</p>
<p><strong>Attack Vector</strong>: Operate malicious indexer reporting
inflated balances.</p>
<p><strong>Cost</strong>: ~$10,000 (server costs) + development
time.</p>
<p><strong>Mitigation Cost</strong>: $0 (users query multiple indexers
for free).</p>
<p><strong>Success Probability</strong>: Near zero (users detect
divergence across indexers).</p>
<p><strong>Conclusion</strong>: Low-cost attack with negligible success
probability. Not economically viable.</p>
<h3 data-number="8.4.3" id="ticker-squatting-attack"><span
class="header-section-number">8.4.3</span> 8.4.3 Ticker Squatting
Attack</h3>
<p><strong>Goal</strong>: Profit from squatting popular tickers before
legitimate projects.</p>
<p><strong>Cost</strong>: ~$50-$500 per ticker (deploy transaction
fee).</p>
<p><strong>Potential Profit</strong>: Speculative (reselling ticker to
project, or scam exit).</p>
<p><strong>Mitigation</strong>: Community curation, wallet warnings,
metadata verification.</p>
<p><strong>Conclusion</strong>: Low-cost nuisance attack. Profitable
only if users fail to verify legitimacy. Social layer mitigation
effective.</p>
<h2 data-number="8.5" id="threat-model-summary"><span
class="header-section-number">8.5</span> 8.5 Threat Model Summary</h2>
<h3 data-number="8.5.1" id="security-hierarchy"><span
class="header-section-number">8.5.1</span> 8.5.1 Security Hierarchy</h3>
<p><strong>Layer 1: Bitcoin Consensus (Trustless)</strong></p>
<ul>
<li>✅ Stamp data permanence guaranteed by PoW</li>
<li>✅ Reversal requires &gt;$20B attack (infeasible)</li>
<li>✅ Data availability as long as Bitcoin operates</li>
</ul>
<p><strong>Layer 2: Indexer Validation (Trust-Minimized)</strong></p>
<ul>
<li>⚠️ Requires trust in indexer validation logic</li>
<li>✅ Mitigated by multi-indexer consensus</li>
<li>✅ Open-source, verifiable by anyone</li>
<li>⚠️ State divergence bugs possible (rare, detectable, fixable)</li>
</ul>
<p><strong>Layer 3: Application Layer (Trust-Dependent)</strong></p>
<ul>
<li>⚠️ Wallets/explorers may report false data</li>
<li>⚠️ Users must verify application integrity</li>
<li>✅ Mitigated by using reputable services</li>
</ul>
<h3 data-number="8.5.2" id="risk-matrix"><span
class="header-section-number">8.5.2</span> 8.5.2 Risk Matrix</h3>
<table>
<thead>
<tr class="header">
<th>Threat</th>
<th>Likelihood</th>
<th>Impact</th>
<th>Mitigation</th>
<th>Residual Risk</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>51% attack</strong></td>
<td>Very Low</td>
<td>Critical</td>
<td>Bitcoin PoW</td>
<td>Negligible</td>
</tr>
<tr class="even">
<td><strong>UTXO pruning</strong></td>
<td>None</td>
<td>N/A</td>
<td>Consensus-critical storage</td>
<td>None</td>
</tr>
<tr class="odd">
<td><strong>Indexer bug</strong></td>
<td>Low</td>
<td>Medium</td>
<td>Multi-indexer consensus</td>
<td>Low</td>
</tr>
<tr class="even">
<td><strong>Malicious indexer</strong></td>
<td>Medium</td>
<td>Low</td>
<td>User verification</td>
<td>Very Low</td>
</tr>
<tr class="odd">
<td><strong>Front-running</strong></td>
<td>Medium</td>
<td>Low</td>
<td>Privacy tools</td>
<td>Medium</td>
</tr>
<tr class="even">
<td><strong>Ticker squatting</strong></td>
<td>High</td>
<td>Low</td>
<td>Social consensus</td>
<td>Low</td>
</tr>
<tr class="odd">
<td><strong>Replay attack</strong></td>
<td>Very Low</td>
<td>Low</td>
<td>Chain consensus</td>
<td>Very Low</td>
</tr>
</tbody>
</table>
<h3 data-number="8.5.3" id="security-recommendations"><span
class="header-section-number">8.5.3</span> 8.5.3 Security
Recommendations</h3>
<p><strong>For Users</strong>: 1. <strong>Verify balances across
multiple indexers</strong> (stampchain.io, OpenStamps) 2. <strong>Use
reputable wallets</strong> with established track record 3.
<strong>Check deploy metadata</strong> (block height, deployer address)
before transacting 4. <strong>Run own indexer</strong> for maximum
trustlessness (advanced users)</p>
<p><strong>For Developers</strong>: 1. <strong>Implement multi-indexer
queries</strong> in applications 2. <strong>Display divergence
warnings</strong> if indexers disagree 3. <strong>Validate consensus
checkpoints</strong> during indexer sync 4. <strong>Contribute to test
suites</strong> for edge case coverage</p>
<p><strong>For Indexer Operators</strong>: 1. <strong>Connect to diverse
Bitcoin nodes</strong> (prevent eclipse attacks) 2. <strong>Verify
consensus checkpoints</strong> at milestone blocks 3. <strong>Publish
state hashes</strong> for community verification 4. <strong>Run
comprehensive test suites</strong> before deploying updates</p>
<h2 data-number="8.6" id="comparison-with-other-protocols"><span
class="header-section-number">8.6</span> 8.6 Comparison with Other
Protocols</h2>
<h3 data-number="8.6.1" id="bitcoin-stamps-vs-ordinals"><span
class="header-section-number">8.6.1</span> 8.6.1 Bitcoin Stamps vs
Ordinals</h3>
<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 27%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th>Security Property</th>
<th>Bitcoin Stamps</th>
<th>Ordinals (Inscriptions)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Data permanence</strong></td>
<td>✅ Guaranteed (UTXO set)</td>
<td>⚠️ Dependent (witness pruning)</td>
</tr>
<tr class="even">
<td><strong>Consensus enforcement</strong></td>
<td>❌ Indexer-based</td>
<td>❌ Indexer-based</td>
</tr>
<tr class="odd">
<td><strong>Pruning risk</strong></td>
<td>✅ None</td>
<td>⚠️ Possible (witness data)</td>
</tr>
<tr class="even">
<td><strong>51% attack protection</strong></td>
<td>✅ Full Bitcoin PoW</td>
<td>✅ Full Bitcoin PoW</td>
</tr>
<tr class="odd">
<td><strong>Archival dependency</strong></td>
<td>✅ None (full nodes sufficient)</td>
<td>⚠️ Requires archival nodes</td>
</tr>
<tr class="even">
<td><strong>Long-term guarantee</strong></td>
<td>✅ As long as Bitcoin exists</td>
<td>⚠️ Depends on node policies</td>
</tr>
</tbody>
</table>
<h3 data-number="8.6.2" id="bitcoin-stamps-vs-counterparty"><span
class="header-section-number">8.6.2</span> 8.6.2 Bitcoin Stamps vs
Counterparty</h3>
<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 33%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="header">
<th>Security Property</th>
<th>Bitcoin Stamps</th>
<th>Counterparty</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Data storage</strong></td>
<td>✅ UTXO set (multisig/P2WSH)</td>
<td>⚠️ OP_RETURN (80 bytes, prunable)</td>
</tr>
<tr class="even">
<td><strong>Asset model</strong></td>
<td>✅ Account-based (inherited)</td>
<td>✅ Account-based</td>
</tr>
<tr class="odd">
<td><strong>Protocol maturity</strong></td>
<td>⚠️ Young (est. 2023)</td>
<td>✅ Mature (est. 2014)</td>
</tr>
<tr class="even">
<td><strong>Indexer diversity</strong></td>
<td>⚠️ Limited implementations</td>
<td>✅ Multiple implementations</td>
</tr>
<tr class="odd">
<td><strong>Permanence guarantee</strong></td>
<td>✅ UTXO-based</td>
<td>⚠️ OP_RETURN (smaller, prunable)</td>
</tr>
</tbody>
</table>
<p><strong>Key Difference</strong>: Counterparty uses 80-byte OP_RETURN
outputs (provably unspendable, smaller data). Bitcoin Stamps use
multisig/P2WSH for larger data and stronger permanence guarantees.</p>
<hr />
<h2 data-number="8.7" id="future-security-considerations"><span
class="header-section-number">8.7</span> 8.7 Future Security
Considerations</h2>
<h3 data-number="8.7.1" id="quantum-computing-threat"><span
class="header-section-number">8.7.1</span> 8.7.1 Quantum Computing
Threat</h3>
<p><strong>Threat</strong>: Quantum computers (Shor’s algorithm) can
break ECDSA signatures, potentially allowing theft of funds from known
public keys.</p>
<p><strong>Impact on Stamps</strong>:</p>
<ul>
<li>Stamp data permanence unaffected (data is public, not secret)</li>
<li>UTXO spending risk if quantum attacker derives private keys</li>
<li>Indexer validation logic unaffected (no cryptographic secrets)</li>
</ul>
<p><strong>Mitigation</strong>:</p>
<ul>
<li>Use burn addresses (no private key exists → quantum-proof)</li>
<li>Future stamps may use quantum-resistant signatures (post-quantum
cryptography)</li>
<li>Bitcoin-level mitigation (soft fork to quantum-resistant signatures)
protects all stamps</li>
</ul>
<h3 data-number="8.7.2" id="bitcoin-protocol-changes"><span
class="header-section-number">8.7.2</span> 8.7.2 Bitcoin Protocol
Changes</h3>
<p><strong>Threat</strong>: Future Bitcoin soft/hard forks may affect
stamp permanence guarantees.</p>
<p><strong>Potential Risks</strong>:</p>
<ul>
<li>UTXO set pruning mechanisms (BIP proposal: stateless
validation)</li>
<li>Changes to multisig or P2WSH validation rules</li>
<li>Block size reductions affecting stamp relay</li>
</ul>
<p><strong>Mitigation</strong>:</p>
<ul>
<li>Community monitoring of Bitcoin Core development</li>
<li>Participation in BIP discussions affecting data storage</li>
<li>Fork contingency plans (maintain support for longest PoW chain)</li>
</ul>
<h3 data-number="8.7.3" id="regulatory-challenges"><span
class="header-section-number">8.7.3</span> 8.7.3 Regulatory
Challenges</h3>
<p><strong>Threat</strong>: Jurisdictions may ban stamp creation or
indexing.</p>
<p><strong>Impact</strong>:</p>
<ul>
<li>Stamp data remains on-chain (cannot be removed by regulation)</li>
<li>Indexers may shut down in restricted jurisdictions</li>
<li>Wallets may delist stamp functionality</li>
</ul>
<p><strong>Mitigation</strong>:</p>
<ul>
<li>Geographic indexer distribution (censorship-resistant)</li>
<li>Open-source code enables permissionless operation</li>
<li>Tor/VPN access to indexers in permissive jurisdictions</li>
<li>Decentralized indexer networks (future research)</li>
</ul>
<hr />
<p><strong>References</strong>:</p>
<ul>
<li><a href="https://en.bitcoin.it/wiki/Weaknesses">Bitcoin Security
Model</a></li>
<li><a href="https://www.crypto51.app/">51% Attack Cost
Analysis</a></li>
<li><a href="https://research.mempool.space/utxo-set-report/">UTXO Set
Research</a></li>
<li><a
href="https://counterparty.io/docs/protocol_specification/">Counterparty
Security Model</a></li>
<li><a
href="https://bitcoinmagazine.com/technical/bitcoin-stamps-vs-ordinals-permanence">Ordinals
vs Stamps Permanence Debate</a></li>
</ul>
<hr />
<h1 data-number="9" id="future-work"><span
class="header-section-number">9</span> 9. Future Work</h1>
<p>Bitcoin Stamps protocol evolution is governed by the <strong>Stamps
Improvement Proposal (SIP)</strong> process, ensuring community-driven,
backward-compatible development. This section summarizes active research
areas; detailed specifications live in individual SIPs.</p>
<h2 data-number="9.1" id="active-sip-proposals"><span
class="header-section-number">9.1</span> 9.1 Active SIP Proposals</h2>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 25%" />
<col style="width: 28%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="header">
<th>SIP</th>
<th>Title</th>
<th>Status</th>
<th>Impact</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SIP-0001</td>
<td>Conditional Transfers / HTLC</td>
<td>Draft</td>
<td>Escrows, atomic swaps, time-locks</td>
</tr>
<tr class="even">
<td>SIP-0003</td>
<td>Cross-Chain Bridges</td>
<td>Research</td>
<td>Layer 2 interoperability</td>
</tr>
<tr class="odd">
<td>SIP-0004</td>
<td>Privacy Enhancements</td>
<td>Research</td>
<td>Confidential amounts, stealth addresses</td>
</tr>
<tr class="even">
<td>SIP-0005</td>
<td>Binary Transfer Format</td>
<td>Draft</td>
<td>40-60% transfer cost reduction</td>
</tr>
<tr class="odd">
<td>SIP-0006</td>
<td>Native SRC-20 AMM</td>
<td>Research</td>
<td>On-chain liquidity pools</td>
</tr>
<tr class="even">
<td>SIP-0007</td>
<td>Wrapped Asset Standard</td>
<td>Research</td>
<td>Cross-chain asset representation</td>
</tr>
<tr class="odd">
<td>SIP-0008</td>
<td>Dual Transaction Parsing</td>
<td>Draft</td>
<td>Combined stamp + SRC-20 operations</td>
</tr>
</tbody>
</table>
<p>For full SIP specifications, see the <a
href="https://github.com/stampchain-io/btc_stamps/issues?q=label%3ASIP">SIP
registry on GitHub</a>.</p>
<h2 data-number="9.2" id="research-directions"><span
class="header-section-number">9.2</span> 9.2 Research Directions</h2>
<h3 data-number="9.2.1" id="defi-primitives"><span
class="header-section-number">9.2.1</span> DeFi Primitives</h3>
<p><strong>Conditional transfers</strong> (SIP-0001) introduce
programmable conditions to SRC-20 operations — time-locks, oracle
attestations, multi-signature thresholds, and atomic swaps. These enable
escrow services, decentralized exchange, vesting schedules, and
crowdfunding, all while preserving the account-based balance model.</p>
<p><strong>Key constraint</strong>: SRC-20 is account-based, not
UTXO-based. DeFi primitives must work through indexer-tracked locked
balances and condition evaluation, not by locking tokens in specific
UTXOs.</p>
<h3 data-number="9.2.2" id="privacy"><span
class="header-section-number">9.2.2</span> Privacy</h3>
<p><strong>Phased approach</strong> (SIP-0004): 1. <strong>Confidential
amounts</strong> — Pedersen commitments hide transfer amounts while
indexers verify balance preservation 2. <strong>Stealth
addresses</strong> — One-time addresses prevent address linkage 3.
<strong>Zero-knowledge proofs</strong> — Exploratory research for full
sender/recipient/amount privacy</p>
<p>Privacy features are opt-in; transparent transfers remain available
for compliance and auditability.</p>
<h3 data-number="9.2.3" id="cross-chain-bridges"><span
class="header-section-number">9.2.3</span> Cross-Chain Bridges</h3>
<p><strong>SIP-0003</strong> proposes federated multisig bridges to
Layer 2 protocols (Lightning Network, Liquid, Stacks). Bridge
lock/unlock records live permanently on Layer 1 while wrapped tokens
circulate on L2 for faster, cheaper transfers. Research into BitVM-based
trustless bridges continues.</p>
<h3 data-number="9.2.4" id="protocol-optimizations"><span
class="header-section-number">9.2.4</span> Protocol Optimizations</h3>
<p><strong>Binary transfer format</strong> (SIP-0005) eliminates JSON
overhead for SRC-20 transfers, reducing transaction size by 40-60%.
<strong>Dual transaction parsing</strong> (SIP-0008) enables single
transactions to perform both stamp creation and SRC-20 operations.</p>
<h2 data-number="9.3" id="design-principles-1"><span
class="header-section-number">9.3</span> 9.3 Design Principles</h2>
<p>All protocol extensions must satisfy:</p>
<ol type="1">
<li><strong>Preserve UTXO permanence</strong> — Consensus-critical data
storage in Bitcoin UTXO set</li>
<li><strong>Account-based compatibility</strong> — Work with existing
balance model, no forced UTXO-token migration</li>
<li><strong>Indexer feasibility</strong> — Implementable by community
indexers without excessive computational burden</li>
<li><strong>Activation lead time</strong> — Consensus changes require 4+
weeks advance notice at specified block height</li>
<li><strong>Graceful degradation</strong> — Legacy indexers continue
functioning for existing stamps</li>
</ol>
<h2 data-number="9.4" id="long-term-vision"><span
class="header-section-number">9.4</span> 9.4 Long-Term Vision</h2>
<p>Bitcoin Stamps positions Bitcoin as the canonical permanent data
storage layer. Future Bitcoin upgrades — OP_CAT covenants, drivechains
(BIP 300/301), BitVM — may reduce indexer trust assumptions by enabling
on-chain validation of stamp rules. Stamps will inherit quantum
resistance from any future Bitcoin cryptographic upgrades.</p>
<p>The protocol’s future is shaped by community contributions through
the SIP process. All are invited to participate.</p>
<hr />
<p><strong>Get Involved</strong>:</p>
<ul>
<li><strong>GitHub</strong>: https://github.com/stampchain-io/btc_stamps
(contribute code, submit SIPs)</li>
<li><strong>Telegram</strong>: https://t.me/BitcoinStamps (community
hub)</li>
<li><strong>Discord</strong>: https://discord.gg/stampchain (community
discussions)</li>
<li><strong>Twitter</strong>: @stampchain (protocol updates)</li>
<li><strong>Developer Docs</strong>: https://docs.stampchain.io (API
references, tutorials)</li>
</ul>
<hr />
<p><strong>Table of Contents</strong>: <a href="./index.md">↑ Whitepaper
Index</a></p>
</body>
</html>
